# 计算机网络概论

## 前言 & 课程介绍

> 课程目标和收益
>
> - 建立对计算机网络的整体认知，对计算机网络中的各种概念（网络分层、网络协议、网络应用等）有初步的理解。
>   进而可以在后续的实际工作中能高效解决网络问题。

### 课程内容

- 通过一个示例建立对计算机网络的整体认识
- 建立对网络协议分层的认知
- 分析HTTP1、2、3的关系
- 介绍CDN运行的基本原理
- 了解网络安全的最基本原则

### 分析方法

- 自底向上
  - 从简单开始，逐渐变复杂
  - 将模块逐步拼凑成一个系统

- 自顶向下
  - 从复杂开始，逐渐变简单
  - 从复杂的系统问题入手，拆分为模块问题

## 蟹堡往帝国

> 一个富含计算机网络思想的故事

- 三步走战略
  1. 在比奇堡开通外卖
  2. 在北京和上海开分店
  3. 在全国开分店并开通外卖

![image-20230413105039418](.\byte-images\image-20230413105039418.png)

![image-20230413105103204](.\byte-images\image-20230413105103204.png)![image-20230413105103818](.\byte-images\image-20230413105103818.png)

![image-20230413105127103](.\byte-images\image-20230413105127103.png)

## 计算机网络基础

### 网络组成部分

- 主机：客户端和服务端
- 路由器
- 网络协议

### 网络结构：网络的网络

- 比奇堡和小区网络：本地网络

> 本地网络（Local Area Network，简称 LAN）是指一个相对较小的地理范围内（例如家庭、学校、公司或办公楼）的计算机和其他设备通过网络媒介相互连接的系统。本地网络的主要目的是实现这些设备间的资源共享、数据传输和通信。
>
> 本地网络的典型特点包括：
>
> 1. 范围有限：通常覆盖一个较小的地理区域，如同一栋建筑物或一个园区。
> 2. 高速传输：相较于广域网（WAN），本地网络内的数据传输速度通常较快。
> 3. 私有所有：本地网络通常由组织或个人拥有和管理。
> 4. 设备多样：本地网络内可能包括计算机、打印机、服务器、网络存储设备等各种设备。
> 5. 通信协议：本地网络通常使用 Ethernet（以太网）或 Wi-Fi（无线局域网）作为通信协议。
>
> 使用本地网络的好处包括便捷地共享资源（如打印机、文件和应用程序）、降低通信成本、提高工作效率和便于设备之间的协作。

- 北京和上海分店+比奇堡：三个本地网络节点的网络

> 本地网络节点（Local Network Node）是指在本地网络（LAN）中的一个设备，例如计算机、服务器、打印机或路由器等。每个节点在网络中都有一个唯一的地址，通常称为IP地址。这个地址用于在网络中识别和定位特定的设备。在数据传输过程中，这些地址会帮助网络设备将信息发送到正确的目的地。
>
> 本地网络节点之间的通信通常通过交换机（Switch）或路由器（Router）实现。交换机主要负责在同一局域网内设备之间转发数据包，而路由器主要负责在不同网络之间转发数据包，如在本地网络和互联网之间。
>
> 在本地网络内，节点之间可以通过有线（如以太网）或无线（如Wi-Fi）连接相互通信。使用有线连接时，设备之间通过网线连接，传输速度较快且稳定；而无线连接则无需网线，更加便捷，但可能受到环境因素影响，导致传输速度波动。

- 全国通信网络：本地网络的网络

> 在一个大型组织或企业环境中，通常会使用子网划分（subnetting）对本地网络进行划分。子网划分的目的是将一个大的网络划分为多个较小的子网络，以实现更好的网络管理、降低网络拥塞和提高安全性。这些子网络可以根据部门、地理位置或功能进行划分。
>
> 子网划分是通过对IP地址进行按位与操作来实现的。使用子网掩码（subnet mask）可以确定一个IP地址属于哪个子网。在子网划分后，同一子网内的设备可以直接通信，而跨子网通信需要通过路由器（router）实现。
>
> 总结一下，在一个本地网络（LAN）中，可以根据实际需求将其划分为多个子网络。这些子网络有助于实现更有效的网络管理、提高安全性和降低网络拥塞。

- 区域网络、城域网和广域网

> 1. **区域网络**（Metropolitan Area Network，简称 MAN）：区域网络覆盖一个城市或城市群，比本地网络（LAN）的范围更大，但比广域网（WAN）小。典型的应用场景包括连接同一城市内的多个企业办公楼、大学校园、政府机构等。区域网络通常使用高速光纤或其他高速传输介质，可以提供较高的数据传输速率。
> 2. **城域网**（Campus Area Network，简称 CAN）：城域网是指覆盖一个学校、大学或企业园区范围内的计算机网络。城域网的规模介于本地网络（LAN）和区域网络（MAN）之间。城域网通常由多个相互连接的局域网组成，以实现资源共享、通信和数据传输。城域网可以使用有线（如以太网）和无线（如 Wi-Fi）连接。
> 3. **广域网**（Wide Area Network，简称 WAN）：广域网覆盖一个很大的地理区域，如国家、地区甚至全球。广域网通过远程通信链路和中继设备连接多个本地网络、区域网络和城域网。典型的广域网应用包括互联网、电话公司的网络和大型企业的全球网络。广域网的数据传输速率通常较低，因为它们需要跨越更大的距离并涉及更多的中继设备。
>
> 这些网络类型之间的主要区别在于覆盖范围、传输速率和管理复杂性。不同类型的网络适用于不同的应用场景，如资源共享、通信和数据传输

### 电路交换&分组交换

> 电路交换和分组交换是两种不同的网络通信技术。它们在传输数据时采用不同的方法和机制。
>
> 1. 电路交换（Circuit Switching）： 电路交换最早用于电话系统，主要用于语音通信。在电路交换中，通信双方之间建立一条固定的、专用的物理通信路径。在通话过程中，这条路径会一直被保留，直到通话结束。数据沿着这条路径顺序传输。
>
> 电路交换的主要特点和缺点如下：
>
> - 确保了连续性：由于通信双方之间有一条专用的通信路径，因此数据传输具有连续性和实时性，适用于实时通信，如电话通话。
> - 低效：在通信过程中，即使没有数据传输，通信路径也会一直被占用。这可能导致资源浪费，尤其在数据传输量不大的情况下。
> - 通话建立时间较长：在建立通话之前，需要为通信双方分配一条物理路径，这个过程可能需要较长的时间。
>
> 1. 分组交换（Packet Switching）： 分组交换是现代计算机网络（如互联网）中主要使用的通信技术。在分组交换中，数据被切分成多个数据包（或称分组），每个数据包独立传输。数据包在网络中根据最佳路由选择相应的路径，最终在目的地重新组装成原始数据。
>
> 分组交换的主要特点和优点如下：
>
> - 高效：数据包在网络中独立传输，可以根据网络拥塞情况动态选择最佳路径。这样可以实现更高效的资源利用和更快的数据传输速率。
> - 弹性：由于数据包可以通过不同的路径传输，因此分组交换网络具有较强的抗干扰能力和容错性。
> - 适用于多种应用：分组交换可以处理多种类型的数据（如文本、图像、音频和视频），非常适合复杂的计算机网络应用。
>
> 电路交换和分组交换是两种截然不同的通信技术。电路交换主要用于实时通信，如电话系统，而分组交换则广泛应用于现代计算机网络，如互联网。分组交换具有更高的资源利用率和更强的适应性，因此在大多数场景下，分组交换是更优的选择

### 网络分层

> 计算机网络的七层结构通常指的是 OSI（Open Systems Interconnection）模型，即开放式系统互联模型。OSI 模型是一个用于描述网络协议的分层架构，它将网络通信过程划分为七个层次，每层负责处理不同的通信任务。从底层到顶层，这些层次分别是：
>
> 1. 物理层（Physical Layer）： 物理层负责处理与物理介质（如电缆、光纤等）相关的通信任务，包括数据的比特流传输、信号编码、硬件接口等。在这一层，数据以比特（bit）为单位进行传输。
> 2. 数据链路层（Data Link Layer）： 数据链路层负责建立、维护和断开数据链路，以确保从源到目的地的可靠数据传输。此外，数据链路层还负责进行错误检测和流量控制。在这一层，数据以帧（frame）为单位进行传输。
> 3. 网络层（Network Layer）： 网络层负责处理网络寻址和路由选择，以确定数据包从源节点到目的节点的最佳路径。网络层使用 IP 地址进行寻址。此外，网络层还负责处理分组和重组数据包。在这一层，数据以数据包（packet）为单位进行传输。
> 4. 传输层（Transport Layer）： 传输层负责提供端到端的通信服务，包括数据的分段、传输、重组和确认。传输层还负责处理流量控制和差错控制。常见的传输层协议有 TCP（传输控制协议）和 UDP（用户数据报协议）。
> 5. 会话层（Session Layer）： 会话层负责建立、管理和断开网络中的通信会话。会话层通过会话标识符来区分不同的通信会话，以确保数据流向正确的目的地。
> 6. 表示层（Presentation Layer）： 表示层负责处理数据的表示和编码问题，以确保发送方和接收方的数据格式兼容。此外，表示层还负责进行数据加密和解密、数据压缩和解压缩等操作。
> 7. 应用层（Application Layer）： 应用层是网络协议栈的最顶层，负责处理与特定应用程序相关的通信任务。应用层协议通常与用户直接交互，例如 HTTP（超文本传输协议）、FTP（文件传输协议）和 SMTP（简单邮件传输协议）等。
>
> 通过将网络通信过程划分为七个层次，OSI 模型有助于简化网络协议的设计

**字节课程这里主要关注上三层网络分层的部分**，且这里说的是五层

- 在实际应用中，网络模型经常会简化为五层模型。五层模型与 OSI 七层模型的主要区别在于它将会话层、表示层和应用层合并为一个层次，并将物理层和数据链路层合并为一个层次。

> 1. 物理层和数据链路层（Physical and Data Link Layers）： 这个层次结合了 OSI 模型中的物理层和数据链路层，负责处理数据链路的建立、维护和断开，以及物理介质上的比特流传输和信号编码等任务。
> 2. **网络层**（Network Layer）： 网络层与 OSI 模型中的网络层相同，负责处理网络寻址和路由选择，以确定数据包从源节点到目的节点的最佳路径。
> 3. **传输层**（Transport Layer）： 传输层与 OSI 模型中的传输层相同，负责提供端到端的通信服务，包括数据的分段、传输、重组和确认。传输层还负责处理流量控制和差错控制。
> 4. **应用层**（Application Layer）： 这个层次结合了 OSI 模型中的会话层、表示层和应用层，负责处理与特定应用程序相关的通信任务，以及数据的表示和编码问题。
>
> 五层模型在实际应用中非常常见，因为它相对于七层模型更加简洁，同时涵盖了网络通信的主要功能。五层模型的应用可以简化网络协议的设计和实现，便于网络设备和协议的互操作。

- 快递员(快递公司类比应用层)不关心包裹内容
- 卡车司机(类比传输层)不关心车厢里拉的是什么
- 高速公路(类比网络层)不关心开的什么车

### 网络协议

> 网络基础协议是指在计算机网络中实现各种功能的一组规定，这些规定描述了数据在网络中的传输方式、格式和处理过程，这里列出一些常见的计算机网络协议
>
> 1. IP（Internet Protocol，互联网协议）： IP 是网络层的主要协议，负责处理网络寻址和数据包在网络中的传输。IP 使用 32 位（IPv4）或 128 位（IPv6）的地址来唯一标识网络中的每个设备。IP 协议可以在不同类型的网络和设备之间提供互通性。
> 2. ICMP（Internet Control Message Protocol，互联网控制报文协议）： ICMP 是 IP 协议的一个辅助协议，用于在网络中传输控制和错误信息。ICMP 的典型应用场景包括网络故障诊断（如 ping 命令）和路由器之间的通信。
> 3. ARP（Address Resolution Protocol，地址解析协议）： ARP 是一种数据链路层协议，用于将网络层的 IP 地址映射到数据链路层的物理地址（如 MAC 地址）。ARP 协议使得 IP 数据包可以在本地网络中正确传输到目的设备。
> 4. TCP（Transmission Control Protocol，传输控制协议）： TCP 是传输层的主要协议，提供了面向连接的、可靠的数据传输服务。TCP 通过握手过程建立连接，使用序列号和确认机制确保数据的可靠传输，以及使用滑动窗口机制实现流量控制。
> 5. UDP（User Datagram Protocol，用户数据报协议）： UDP 也是传输层的一种协议，但与 TCP 不同，它提供的是无连接的、不可靠的数据传输服务。UDP 的优势在于它的传输开销较小，适用于实时性要求较高、允许丢包的应用场景，如实时语音和视频通信。
> 6. DNS（Domain Name System，域名系统）： DNS 是应用层的一种协议，用于将人类可读的域名解析为 IP 地址。DNS 使得用户可以通过域名访问网站和网络服务，而无需记住复杂的 IP 地址。
> 7. HTTP（Hypertext Transfer Protocol，超文本传输协议）： HTTP 是应用层的一种协议，用于在客户端（如浏览器）和服务器之间传输超文本和其他资源。HTTP 是互联网上最常用的协议，构成了万维网（WWW）的基础。
> 8. FTP（File Transfer Protocol，文件传输协议）： FTP 是应用层的一种协议，用于在客户端和服务器之间传输文件。FTP 协议支持对文件的上传、下载、删除、重命名等操作，并提供了对文件访问权限的控制功能。它通常用于在用户和服务器之间共享文件和管理网站内容。
> 9. SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）： SMTP 是应用层的一种协议，用于在邮件服务器之间或客户端到邮件服务器之间发送电子邮件。SMTP 只负责邮件的发送，而接收邮件则需要使用 POP3（邮局协议3）或 IMAP（互联网消息访问协议）等其他协议。
> 10. DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）： DHCP 是应用层的一种协议，用于为网络中的设备动态分配 IP 地址和其他网络配置信息。DHCP 使得网络管理员可以集中管理 IP 地址分配，简化了网络配置和管理工作。
> 11. SSL/TLS（Secure Sockets Layer/Transport Layer Security，安全套接层/传输层安全）： SSL 和 TLS 是应用层的加密协议，用于在客户端和服务器之间建立安全的通信通道。SSL/TLS 可以保护数据的完整性和隐私，防止窃听和篡改。它们广泛应用于安全敏感的场景，如在线支付、登录验证等。

**协议的存在依赖于连接**

- 协议定义了在两个或多个通信实体之间交换的报文格式和顺序，以及报文发送和/或接受一条报文或其他事件所采取的动作。

#### 标头和载荷

> 在计算机网络中，数据通常按照协议的格式进行封装和传输。一个数据包或帧通常分为两部分：标头（Header）和载荷（Payload）。标头和载荷分别承担不同的作用，共同实现数据在网络中的传输和处理。
>
> 1. **标头**（Header）： 标头是数据包或帧的开头部分，包含了用于处理和传输数据的控制信息。标头中的信息根据不同的协议和网络层次而有所不同。一般来说，标头包含了如下信息：
>
> - 源地址和目的地址：标头中通常包含了发送方和接收方的地址信息，如 IP 地址、MAC 地址等。这些地址信息用于确保数据正确传输到目的地。
> - 协议类型：标头中还包含了协议类型信息，以标识数据包属于哪个协议。这有助于网络设备正确处理和转发数据包。
> - 序列号和确认号：对于面向连接的协议（如 TCP），标头中还包含了序列号和确认号，用于实现可靠数据传输和流量控制。
> - 校验和：标头中通常包含了校验和信息，用于检测数据在传输过程中是否发生错误。
> - 其他控制信息：标头中还可能包含其他控制信息，如数据包的生命周期、优先级、标志位等。
>
> 1. **载荷**（Payload）： 载荷是数据包或帧的主体部分，包含了实际要传输的数据。载荷的内容根据不同的应用和场景而有所不同。例如，在传输文件时，载荷中包含了文件的内容；在传输网页时，载荷中包含了 HTML、CSS 和 JavaScript 等网页元素。
>
> 在数据传输过程中，数据包或帧会经过多个网络层次。每个层次都可能为数据添加自己的标头，形成嵌套的结构。这种嵌套结构有时被称为“封装”（Encapsulation）。当数据到达目的地时，每个网络层次会依次去除相应的标头，还原出原始的数据。这个过程被称为“解封装”（Decapsulation）。
>
> 了解标头和载荷的概念有助于理解计算机网络中数据包的结构和传输过程。在网络调试和故障诊断时，分析标头中的信息对于定位问题和解决问题具有重要意义

- HTTP协议示例：应用层-HTTP协议头部

> HTTP（超文本传输协议）是应用层的一个协议，用于在客户端（如浏览器）和服务器之间传输超文本和其他资源。HTTP 协议的请求和响应消息都包含头部（Header）信息，用于描述和控制消息的传输和处理

![image-20230413111654039](.\byte-images\image-20230413111654039.png)

小结

- 网络组成部分：由主机、路由器、交换机等组成
- 网络结构：网络的网络
- 信息交换方式：电路交换和分组交换
- 网络分层：分清职责，物理层、链路层、网络层、运输层和应用层
- 网络协议：标头和载荷

## Web中的网络

### HTTP1

![image-20230413112509909](.\byte-images\image-20230413112509909.png)

#### 请求

```SQL
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Connection: keep-alive
```

- 请求行（Request Line）：`GET /index.html HTTP/1.1`。请求行包含了请求方法（GET）、请求资源的路径（/index.html）和 HTTP 协议版本（HTTP/1.1）。
- Host：`www.example.com`。Host 头部指定了请求的目标服务器域名。
- User-Agent：`Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36`。User-Agent 头部描述了发起请求的客户端（浏览器）的信息，包括操作系统、浏览器类型和版本等。
- Accept：`text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8`。Accept 头部表示客户端支持接收的 MIME 类型。在这个示例中，客户端支持接收 HTML、XHTML、XML 和 WebP 等格式的内容。
- Accept-Language：`en-US,en;q=0.5`。Accept-Language 头部表示客户端支持的语言和优先级。在这个示例中，客户端优先支持美国英语，其次是其他英语。
- Connection：`keep-alive`。Connection 头部表示连接的控制选项。在这个示例中，keep-alive 表示客户端希望保持连接，以便在多个请求之间复用 TCP 连接。

#### 响应

HTTP 协议中的响应是服务器针对客户端请求所作出的回应。响应消息包含状态行、响应头部和响应体三部分。以下是一个简化的 HTTP 响应示例：

```sql
HTTP/1.1 200 OK
Date: Mon, 23 May 2022 22:38:34 GMT
Server: Apache/2.4.1 (Unix)
Content-Type: text/html; charset=UTF-8
Content-Length: 138
Last-Modified: Sun, 22 May 2022 15:28:12 GMT
Connection: close

<!DOCTYPE html>
<html>
<head>
    <title>Example Page</title>
</head>
<body>
    <h1>Hello, XiaoYu!</h1>
</body>
</html>
```

- 状态行（Status Line）：`HTTP/1.1 200 OK`。状态行包含 HTTP 协议版本（HTTP/1.1）、状态码（200）和状态描述（OK）。状态码 200 表示请求已成功处理。
- Date：`Mon, 23 May 2022 22:38:34 GMT`。Date 头部表示响应生成的日期和时间。
- Server：`Apache/2.4.1 (Unix)`。Server 头部描述了生成响应的服务器软件和版本信息。
- Content-Type：`text/html; charset=UTF-8`。Content-Type 头部指定了响应体的媒体类型（MIME 类型）和字符编码。在这个示例中，响应体的内容是 HTML 格式，字符编码为 UTF-8。
- Content-Length：`138`。Content-Length 头部表示响应体的字节长度。
- Last-Modified：`Sun, 22 May 2022 15:28:12 GMT`。Last-Modified 头部表示请求资源的最后修改时间。
- Connection：`close`。Connection 头部表示连接的控制选项。在这个示例中，close 表示服务器在发送完响应后将关闭 TCP 连接。
- 响应体（Response Body）：响应体包含实际返回的数据，通常是 HTML、JSON、XML 等格式的内容。在这个示例中，响应体是一个简单的 HTML 页面。

### HTTP连接模型

> 1. **无连接模型**： 在早期的 HTTP/1.0 版本中，HTTP 使用无连接模型。这意味着每个 HTTP 请求和响应都需要建立一个新的 TCP 连接。在处理完一个请求后，服务器会关闭连接。这种模型简单易实现，但在高延迟和大量并发请求的场景下，性能较差。每个连接的建立和关闭都会消耗资源和时间，导致延迟增加和服务器负载过高。
> 2. **持久连接模型**： 为了解决无连接模型的性能问题，HTTP/1.1 引入了持久连接（Persistent Connection）模型，也称为 Keep-Alive 连接。在持久连接模型中，客户端和服务器可以在一个 TCP 连接上发送多个 HTTP 请求和响应。这种模型减少了 TCP 连接的建立和关闭次数，降低了延迟和服务器负载，提高了性能。持久连接在 HTTP/1.1 中是默认启用的，可以通过 Connection 请求头部的值（Keep-Alive 或 close）进行控制。
> 3. **管道化连接模型**： HTTP/1.1 还引入了管道化（Pipelining）连接模型，它允许客户端在收到上一个请求的响应之前，连续发送多个请求。服务器会按照请求的顺序依次处理，并按顺序返回响应。这种模型进一步提高了连接的利用率和性能。但由于实际部署中的兼容性和实现问题，HTTP/1.1 的管道化并未广泛应用。

![image-20230413112722877](.\byte-images\image-20230413112722877.png)

#### 队头堵塞

**HTTP1.1：无法多路复用**

HTTP/1.1 无法实现多路复用的主要原因是其基于文本的请求和响应格式以及协议设计。在 HTTP/1.1 中，每个请求和响应都是一个完整的文本消息，必须按照顺序发送和接收。这导致了一种称为“队头阻塞”（Head-of-Line Blocking）的问题，即一个请求或响应的处理延迟会影响后续的请求和响应，无法并行处理。虽然 HTTP/1.1 引入了管道化技术以尝试提高性能，但由于实际部署中的兼容性和实现问题，管道化并未广泛应用。

相比之下，HTTP/2 能实现多路复用的原因如下：

1. 二进制分帧：HTTP/2 把请求和响应分解为多个二进制帧，每个帧都有一个唯一的标识符。这使得客户端和服务器能够在一个 TCP 连接上同时发送和接收多个请求和响应的帧，而不会产生队头阻塞问题。
2. 流（Stream）：HTTP/2 引入了流的概念，每个请求和响应都有一个独立的流。流可以并行处理，每个流的帧可以独立发送和接收，而不受其他流的影响。这使得多个请求和响应可以在一个 TCP 连接上并行传输，实现多路复用。
3. 优先级和依赖：HTTP/2 还支持为每个流设置优先级和依赖关系。客户端可以通过优先级和依赖信息告诉服务器哪些请求更重要，哪些请求需要先完成。这样，服务器可以更有效地利用资源，优先处理重要的请求，进一步提高性能。
4. 流量控制：HTTP/2 引入了更为精细的流量控制机制，客户端和服务器可以独立地为每个流设置发送窗口大小，以控制每个流的传输速率。这有助于避免一个流占用过多带宽，影响其他流的传输。

总之，HTTP/2 通过引入二进制分帧、流、优先级和依赖以及流量控制等机制，实现了多路复用，克服了 HTTP/1.1 中队头阻塞等性能问题。这些改进使得 HTTP/2 能在一个 TCP 连接上并行处理多个请求和响应，提高了性能和资源利用率。

#### HTTP2的帧

![image-20230413113301113](.\byte-images\image-20230413113301113.png)

> 1. 多路复用连接模型： 在 HTTP/2 中，引入了多路复用（Multiplexing）连接模型。多路复用允许客户端和服务器在一个 TCP 连接上并行发送和接收多个请求和响应。HTTP/2 通过将请求和响应拆分为多个帧（Frame），并为每个请求分配一个独立的流（Stream）来实现多路复用。这种模型进一步提高了连接的利用率和性能，解决了 HTTP/1.1 管道化模型的问题。HTTP/2 还引入了其他优化措施，如头部压缩、服务器推送等，进一步提升了性能。

> 在 HTTP/2 中，帧（Frame）是协议的基本传输单位。HTTP/2 将请求和响应消息分解为多个小的二进制帧，这些帧在客户端和服务器之间传输。每种类型的帧都有特定的目的和格式。使用帧可以实现更高效的多路复用，避免队头阻塞问题，提高传输性能。
>
> 一个 HTTP/2 帧由以下几部分组成：
>
> 1. 长度（Length）：一个 24 位无符号整数，表示帧的负载长度（不包括帧头部的 9 个字节）。长度最大值为 2^24 - 1 字节（约 16MB）。
> 2. 类型（Type）：一个 8 位无符号整数，表示帧的类型。不同类型的帧用于传输不同类型的信息，如 HEADERS、DATA、SETTINGS 等。
> 3. 标志（Flags）：一个 8 位无符号整数，表示帧的特定属性。每种类型的帧都有自己的标志集合，用于控制帧的行为。
> 4. 保留位（R）：一个 1 位保留位，目前未使用，必须设置为 0。
> 5. 流标识符（Stream Identifier）：一个 31 位无符号整数，表示帧所属的流。流是 HTTP/2 中的一个基本概念，每个请求和响应都有一个独立的流。流标识符为 0 的帧表示与整个连接相关的控制帧，而非特定流。
> 6. 负载（Payload）：帧的负载数据，长度由 Length 字段指定。负载的内容和格式取决于帧的类型和标志。
>
> HTTP/2 定义了以下几种类型的帧：
>
> 1. DATA：用于传输请求或响应的主体数据。
> 2. HEADERS：用于传输请求或响应的头部信息。HEADERS 帧可以与 CONTINUATION 帧一起传输较大的头部信息。
> 3. PRIORITY：用于为流设置优先级和依赖关系。
> 4. RST_STREAM：用于终止一个流，表示发生了错误或者不再需要传输该流的数据。
> 5. SETTINGS：用于在客户端和服务器之间交换配置参数。
> 6. PUSH_PROMISE：用于服务器向客户端推送资源，提前发送关联资源的头部信息，提高性能。
> 7. PING：用于测量最小往返时间以及检测连接是否活跃。
> 8. GOAWAY：用于通知对端关闭连接，可以包含诊断信息。
> 9. WINDOW_UPDATE：用于实现流量控制，调整发送窗口大小。
> 10. CONTINUATION：用于在 HEADERS 帧之后继续传输头部信息。
>
> 通过对请求和响应进行二进制分帧处理，HTTP/2 实现了更高效的传输和多路复用。以下是 HTTP/2 帧处理的一些主要优点：
>
> 1. 多路复用：由于每个帧都有一个关联的流，客户端和服务器可以在单个 TCP 连接上同时发送和接收多个请求和响应。这避免了 HTTP/1.1 中的队头阻塞问题，提高了传输性能和资源利用率。
> 2. 优先级和依赖：HTTP/2 允许为每个流设置优先级和依赖关系。客户端可以通过 PRIORITY 帧告诉服务器哪些请求更重要，哪些请求需要先完成。这使服务器能够更有效地分配资源，提高传输性能。
> 3. 流量控制：HTTP/2 引入了更为精细的流量控制机制。客户端和服务器可以通过 WINDOW_UPDATE 帧独立地为每个流设置发送窗口大小，以控制每个流的传输速率。这有助于避免一个流占用过多带宽，影响其他流的传输。
> 4. 服务器推送：HTTP/2 支持服务器推送功能，允许服务器在客户端请求之前主动发送资源。服务器可以通过发送 PUSH_PROMISE 帧，提前发送关联资源的头部信息，以提高页面加载性能。
> 5. 头部压缩：HTTP/2 采用 HPACK 压缩算法对请求和响应头部进行压缩，以减少头部数据的大小。这有助于降低传输延迟，提高性能。
>
> HTTP/2 的二进制帧处理机制实现了更高效的传输和多路复用，解决了 HTTP/1.1 中的队头阻塞问题。此外，HTTP/2 引入了优先级、依赖、流量控制、服务器推送和头部压缩等优化措施，进一步提升了性能和资源利用率

![image-20230413113348159](.\byte-images\image-20230413113348159.png)

帧来带来的好处

- 调整响应传输的优先级
- 头部压缩
- Server Push

HTTP3出现的原因是HTTP2还不够快和解决 HTTP/2 中仍然存在的一些问题和局限性

## HTTP3：QUIC

- Quick UDP Internet Connection
- 现存网络设备对TCP和UDP支持已经僵化
- UDP不靠谱(包丢了就不管了，业务给多少数据，它就发多少数据)但是QUIC靠谱
- QU1C可以为除HTP协议以外的应用层协议提供支持

> HTTP/3 主要是为了解决在面对丢包和网络不稳定的情况下的性能问题。具体来说，HTTP/3 的出现主要是为了解决以下几个问题：
>
>  队头阻塞问题（Head-of-Line Blocking）：尽管 HTTP/2 引入了多路复用和二进制分帧来解决 HTTP/1.1 中的队头阻塞问题，但在 HTTP/2 中，所有的流都共享一个 TCP 连接。当 TCP 连接上的一个数据包丢失时，整个连接上的所有流都会受到影响，导致延迟增加。这种情况在丢包率较高的网络环境中尤为明显。 
>
> TCP 和 TLS 握手：HTTP/2 基于 TCP 协议，建立一个新连接时需要进行 TCP 三次握手。如果使用 HTTPS（基于 TLS 的 HTTP），还需要进行 TLS 握手。这些握手过程增加了连接建立的延迟。特别是在移动网络环境中，这种延迟可能对用户体验产生较大影响。
>
>  连接迁移：HTTP/2 基于 TCP，当用户设备的网络环境发生变化时（例如，从 Wi-Fi 切换到蜂窝网络），TCP 连接可能需要重新建立，导致延迟和资源浪费。HTTP/2 不支持连接迁移，无法实现平滑的网络切换。
>
>  **为了解决上述问题，HTTP/3 引入了一个新的传输层协议——QUIC（Quick UDP Internet Connections）。QUIC 基于 UDP（User Datagram Protocol），而非 TCP**，具有以下优势： 
>
> 避免队头阻塞：QUIC 支持多路复用，且每个流在传输层上独立处理，因此一个流上的数据包丢失不会影响其他流。这样，在面对丢包和网络不稳定的情况下，QUIC 可以在面对丢包和网络不稳定的情况下，QUIC 可以实现更低的延迟，提高性能和用户体验。
>
> 更快的连接建立：由于 QUIC 基于 UDP，它将传输层和加密层的握手过程合并，从而减少了握手次数。这可以减少连接建立的延迟，尤其在网络环境不佳的情况下，对用户体验有很大帮助。
>
> 连接迁移：QUIC 支持连接迁移，当用户设备的网络环境发生变化时，可以实现平滑地从一个网络切换到另一个网络，而不会影响到已有的连接。这有助于减少延迟和资源浪费，提高用户体验。
>
> 错误恢复：QUIC 在丢包恢复方面比 TCP 更加高效，因为它可以更快地识别丢失的数据包并进行重传。这有助于减少延迟和提高传输性能。
>
> HTTP/3 的出现主要是为了解决 HTTP/2 在面对丢包和网络不稳定的情况下的性能问题。通过引入基于 UDP 的 QUIC 协议，HTTP/3 解决了队头阻塞问题，实现了更快的连接建立和连接迁移，提高了错误恢复效率。这使得 HTTP/3 在网络环境不佳的情况下仍能提供良好的性能和用户体验。

![image-20230413113641261](.\byte-images\image-20230413113641261.png)

![image-20230413114518986](.\byte-images\image-20230413114518986.png)

![image-20230413115111434](.\byte-images\image-20230413115111434.png)

![image-20230413115021031](.\byte-images\image-20230413115021031.png)

## CDN

### CDN：你无法突破物理极限的

> 物理极限：现实中的路程距离

- HTTP3快吗？

  快！

- 那从美国到中国，HTP3要多久？
  150ms!

- 和北京到上海比，还快吗？
  好像不够？

### CDN：你的钱包够鼓吗？

- 流量多少钱一个G？
- 1块
- 那我在福建给上海的小满发一部100G的小电影大合集得100块钱？
- 对！
- 发10次岂不是要1000块钱？
- 是的！
- 我都发到北京了，小满就不能跟其他同学内部共享一下吗？

### CND：你，够强大吗？

- 我们有几台服务器？
- 1台
- 他能抗多少流量？
- 100G!
- 双十一峰值得1000G，扛得住吗？
- 不一定，可能会G....

### CDN：DNS劫持

- 域名解析一般由网站自己处理
- 要加速的域名则重定向到CDN厂商的域名解析服务处理(通常不是由自己来解析，而是由CDN厂商来做)
- CDN厂商根据来源确定最近的CDN服务器的IP
- 用户直接访问最近的CDN服务器

> CDN（Content Delivery Network，内容分发网络）是一种用于优化网络资源访问速度和提高用户体验的技术。CDN 的核心思想是将网站或应用程序的内容（如图片、视频、脚本等）缓存到位于不同地理位置的服务器上，使用户可以从最近的服务器获取所需的内容，从而降低延迟、提高访问速度和可用性。
>
> CDN 的主要组成部分包括：
>
> 1. 边缘服务器（Edge Server）：位于各地的服务器，用于缓存和分发内容。当用户请求内容时，CDN 会将请求重定向到最近的边缘服务器，从而加快访问速度。边缘服务器之间会根据一定的策略进行内容同步，确保缓存的内容是最新的。
> 2. 负载均衡器（Load Balancer）：用于在多个边缘服务器之间分发用户请求。负载均衡器根据各边缘服务器的负载情况和用户的地理位置，智能地将请求分配到合适的边缘服务器。
> 3. 域名解析系统（DNS）：CDN 通常会有自己的 DNS 服务，用于将用户的请求重定向到最近的边缘服务器。当用户访问一个使用 CDN 的网站时，DNS 会根据用户的 IP 地址和边缘服务器的位置信息，返回最近的边缘服务器 IP 地址，从而实现请求的重定向。
> 4. 内容管理系统（CMS）：用于管理和维护 CDN 中的内容。内容提供者可以通过 CMS 将内容发布到 CDN，并对内容进行更新、删除等操作。
>
> CDN 的主要优点包括：
>
> 1. 降低延迟：通过将内容缓存到离用户更近的边缘服务器上，CDN 可以显著降低访问延迟，提高用户体验。
> 2. 提高可用性：CDN 能够在多个边缘服务器之间分发流量，从而提高系统的冗余性。当某个边缘服务器出现故障时，用户的请求可以被重新定向到其他可用的服务器，确保服务的正常运行。
> 3. 减轻源站压力：由于大部分用户请求都被 CDN 的边缘服务器处理，源站服务器的压力得到了缓解，从而降低了源站的成本和维护复杂性。
> 4. 节省带宽：CDN 可以通过缓存和压缩技术，有效地减少网络带宽的消耗，降低数据传输成本。
> 5. 安全性：CDN 可以提供诸如 DDoS（分布式拒绝服务）攻击保护、Web 应用程序防火墙等安全措施，保护网站免受攻击和恶意访问。
> 6. 支持动态内容：除了静态内容外，CDN 还可以缓存和分发动态内容，如动态生成的 HTML 页面、Web API 的响应等。
>
> 需要注意的是，CDN 的应用场景和效果并不是完全适用于所有类型的网站和应用程序。特别是对于内容更新频繁的网站或应用程序，使用 CDN 可能会导致更新不及时或者缓存不一致等问题。因此，在使用 CDN 时需要根据具体情况进行评估和权衡。

### 如何选择CDN服务器？

> 选择合适的 CDN 服务器需要考虑多个因素，包括网站流量、用户分布、CDN 服务商的覆盖范围、成本等。以下是一些选择 CDN 服务器的建议：
>
> 1. 流量量：选择 CDN 服务器时，需要考虑网站或应用程序的流量量，尤其是在高流量时段的稳定性。根据实际情况，选择能够满足网站流量需求的服务器。
> 2. 用户分布：选择距离用户最近的服务器，可以降低访问延迟，提高用户体验。根据网站或应用程序的用户分布情况，选择离用户最近的 CDN 服务器。
> 3. CDN 服务商的覆盖范围：选择覆盖范围广泛的 CDN 服务商，可以确保服务的可用性和稳定性。选择具有全球分布的 CDN 服务商，能够满足全球用户的访问需求。
> 4. 成本：选择合适的 CDN 服务器需要考虑成本问题。通常情况下，不同 CDN 服务商的价格和服务质量差异较大。选择适合自己需求的 CDN 服务商，可以确保在满足业务需求的前提下降低成本。
> 5. CDN 服务商的技术支持和服务质量：选择具有良好技术支持和服务质量的 CDN 服务商，可以保障服务的稳定性和安全性。需要注意的是，选择 CDN 服务商时需要进行充分的调研和比较，了解服务商的技术实力和服务质量。
>
> 所以并不只看地理位置一个因素

![image-20230413121131665](.\byte-images\image-20230413121131665.png)

![image-20230413121346331](.\byte-images\image-20230413121346331.png)

CDN 有两种基本的缓存策略：拉取策略（Pull）和推送策略（Push）。

拉取策略，也叫做就近访问策略，指的是 CDN 节点通过 HTTP 请求直接向源站请求数据，然后缓存到本地节点，当用户请求数据时，就直接从缓存的本地节点中获取数据。这种策略主要用于数据更新较少的情况，适用于流量较小、访问频率低的站点。

推送策略，也叫做预先访问策略，指的是将源站的数据推送到 CDN 节点，通过 HTTP 请求缓存到 CDN 节点，当用户请求数据时，直接从缓存的本地节点中获取数据。这种策略适用于数据更新频繁的情况(比如视频举例的热门新电影上线的时候，就可以使用推送策略，全国用户可以第一时间 获取新电影)，可以有效地缓解源站的访问压力，提高用户访问速度。推送策略需要源站和 CDN 之间建立预先配置好的链接，源站通过这个链接将数据推送到 CDN 节点。

拉取策略和推送策略的优缺点如下：

拉取策略：

优点：

1. 可以实时获取最新数据，不需要手动推送数据。
2. 可以有效地缓解源站的访问压力，节省带宽和资源。
3. 部署简单，不需要与源站建立链接。

缺点：

1. 访问速度可能较慢，特别是在访问量较大时。
2. 需要源站保持开放状态，以便 CDN 节点随时请求数据。

推送策略：

优点：

1. 访问速度较快，因为数据已经预先推送到了 CDN 节点。
2. 可以减轻源站的访问压力，提高网站的稳定性和可靠性。

缺点：

1. 需要手动推送数据到 CDN 节点。
2. 可能会出现数据不一致问题，需要定期同步数据。
3. 部署和维护较为复杂，需要建立预先配置好的链接。

## WebSocket

> WebSocket 是一种网络通信协议，可以在客户端和服务器之间实现双向通信。与传统的 HTTP 协议不同，WebSocket 协议在客户端和服务器之间建立持久连接，可以在任何时间点双向通信，而不需要通过 HTTP 请求和响应来进行。WebSocket 协议可以在 Web 应用程序和服务器之间实现实时通信和数据传输，常用于在线游戏、聊天室、实时数据监测等场景。
>
> WebSocket 协议的优点如下：
>
> 1. 实时性：WebSocket 协议可以在客户端和服务器之间实现双向实时通信，可以在任何时间点发送和接收数据，避免了 HTTP 请求和响应的延迟和重复。
> 2. 效率：WebSocket 协议可以在客户端和服务器之间建立持久连接，避免了每次请求和响应的开销，提高了数据传输效率。
> 3. 跨域支持：WebSocket 协议可以支持跨域通信，可以在不同的域名和端口之间进行数据传输。
> 4. 可扩展性：WebSocket 协议可以通过自定义消息格式和协议扩展实现更复杂的应用场景和功能。
>
> WebSocket 协议的实现基于 TCP 协议，使用类似 HTTP 的握手协议建立连接。客户端和服务器之间建立连接后，可以通过 send() 方法发送数据，通过 onmessage() 方法接收数据。客户端和服务器之间的通信是双向的，可以在任何时间点发送和接收数据。当客户端或服务器需要关闭连接时，可以调用 close() 方法关闭连接。
>
> 总之，WebSocket 协议是一种实现双向实时通信的网络通信协议，可以在 Web 应用程序和服务器之间实现实时数据传输和通信。WebSocket 协议可以提高数据传输效率和实时性，适用于在线游戏、聊天室、实时数据监测等场景。

- 有状态的持久连接
- 服务端可以主动推送消息
- 用VebSocket发送消息延迟比HTTP低

### WebSocket代码示例

- 客户端代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebSocket Example</title>
</head>
<body>
  <h1>WebSocket Example</h1>
  <input type="text" id="message">
  <button id="send">Send</button>
  <ul id="messages"></ul>

  <script>
    const messages = document.getElementById('messages');
    const messageInput = document.getElementById('message');
    const sendButton = document.getElementById('send');
    
    // 创建 WebSocket 连接
    const ws = new WebSocket('ws://localhost:3000');

    // 连接成功后执行的回调函数
    ws.addEventListener('open', () => {
      console.log('Connected to WebSocket server');
    });

    // 接收服务器发送的消息并显示在页面上
    ws.addEventListener('message', (event) => {
      const li = document.createElement('li');
      li.textContent = event.data;
      messages.appendChild(li);
    });

    // 发送消息给服务器
    sendButton.addEventListener('click', () => {
      const message = messageInput.value;
      ws.send(message);
      messageInput.value = '';
    });
  </script>
</body>
</html>

```

- 服务端代码

```javascript
const express = require('express');
const http = require('http');
const WebSocket = require('ws');

const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

wss.on('connection', (ws) => {
  console.log('Client connected');

  // 接收客户端发送的消息并广播给所有连接的客户端
  ws.on('message', (message) => {
    console.log(`Received message: ${message}`);
    wss.clients.forEach((client) => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(message);
      }
    });
  });

  // 连接关闭后执行的回调函数
  ws.on('close', () => {
    console.log('Client disconnected');
  });
});

server.listen(3000, () => {
  console.log('WebSocket server started on port 3000');
});
```

**小结**

- HTTP123的演进历史
- CDN解决了HTTP协议之外的问题
  WebSocket从HTTP协议升级而来

## 网络安全

> 无论是HTTP还是UDP等等协议都是明文的，一条消息从一台电脑到另一台电脑中所经过的流程都可以看到消息的所有内容，甚至可以丢弃和篡改。明文会导致很多操作无法进行，比如银行 转账

### 网络安全：三要素

- 机密性：攻击者无法获知通信内容
- 完整性：攻击者对内容进行篡改时能被发现
- 身份验证：攻击者无法伪装成通信双方的任意一方与另一方通信

### 网络安全：对称加密和非对称加密

- 对称加密：加密、解密用同样的密钥

> 对称加密算法是指使用同一个密钥进行加密和解密。发送方使用密钥将明文加密成密文，并将密文发送给接收方，接收方使用相同的密钥将密文解密成明文。对称加密算法具有加密和解密速度快、效率高的特点，但是密钥的安全性是关键问题，如果密钥泄露，则所有加密数据都会被破解。
>
> 常见的对称加密算法包括 DES、3DES、AES 等。其中，AES（Advanced Encryption Standard）是目前应用最广泛的对称加密算法之一，支持多种密钥长度和加密模式，具有高效、安全等优点。

- 非对称加密：加密、解密使用不同的密钥（公钥和私钥），而且**公钥加密只能用私钥解密、私钥加密只能用公钥解密**

> 非对称加密算法是指使用不同的密钥进行加密和解密。发送方使用公钥将明文加密成密文，并将密文发送给接收方，接收方使用私钥将密文解密成明文。因为公钥和私钥是不同的，所以非对称加密算法也称为公钥加密算法。公钥可以公开传播，而私钥只有接收方知道，这样可以保证密钥的安全性。
>
> 常见的非对称加密算法包括 RSA、DSA、ECC 等。其中，RSA 是应用最广泛的非对称加密算法之一，支持加密和数字签名等功能，具有高效、安全等优点。

### 网络安全：密码散列函数（哈希函数）

- 输入：任意长度的内容
- 输出：固定长度的哈希值
- 性质：**找到两个不同的输入使之经过密码散列函数后有相同的哈希值，在计算上是不可能的**

### 网络安全：机密性

- 加密需要加密算法和密钥等信息（**统称为秘密信息**）
- 网络是明文的，不安全

怎么在不安全的信道交换秘密信息？

### 网络安全：完整性和身份验证

**完整性和身份验证相互关联。**

- 蟹老板向银行发起了转账请求
- 银行需要确认
  - 这个请求真的是蟹老板发起的
  - 目标账户和转账金额没有被篡改

#### 如何实现机密性

- 已知：网络是明文的
- 如果**双方可以通过明文通信商量出秘密信息，那么攻击者也可以**
- 所以**想要通过明文通信交换秘密信息，通信双方需要先有秘密信息**，意思就是我们想要通过明文来交换密钥，就得有不会被攻击者知道的秘密信息

#### 如何实现完整性

- 密码散列函数性质：**找到两个不同的输入使之经过密码散列函数后有相同的哈希值，在计算上是不可能的**
- 有明文m,密码散列函数H
- 计算H(m)获得哈希值h
- 将m和h组合成新信息m+h
- 接收方拆分m+h,重新计算H(m)得h',对比h'和h

![image-20230413124431333](.\byte-images\image-20230413124431333.png)

### 如何实现身份验证

> 数字签名是一种基于公钥加密技术的技术，用于保证数据的完整性、不可否认性和真实性。它通常使用非对称加密算法进行实现，如 RSA、DSA 等。
>
> 在数字签名中，发送方首先对原始数据进行哈希运算，得到一个唯一的、固定长度的哈希值。然后，发送方使用自己的私钥对这个哈希值进行加密，形成数字签名，并将数字签名和原始数据一起发送给接收方。接收方可以使用发送方的公钥来验证数字签名的真实性和完整性。
>
> 验证数字签名的过程如下：
>
> 1. 接收方对原始数据进行哈希运算，得到一个哈希值。
> 2. 接收方使用发送方的公钥对数字签名进行解密，得到一个哈希值。
> 3. 接收方比较这两个哈希值是否相同，如果相同，则说明数字签名是有效的，原始数据没有被篡改。
>
> 这个过程的核心在于发送方使用私钥对哈希值进行加密，只有持有私钥的发送方才能够生成有效的数字签名，因此数字签名可以被认为是发送方对原始数据的“数字指纹”。同时，接收方使用公钥对数字签名进行解密，只有持有公钥的发送方才能够生成有效的数字签名，因此可以保证数字签名的真实性和完整性。
>
> 总之，数字签名是一种基于公钥加密技术的技术，用于保证数据的完整性、不可否认性和真实性。它通过对原始数据进行哈希运算和使用发送方的私钥进行加密，生成数字签名，然后通过使用发送方的公钥对数字签名进行解密和验证，保证数据的安全性和可靠性。

- 签名：用于鉴别身份和防止伪造
- 非对称加密性质：加密、解密使用不同的密钥（公钥和私钥），而且公钥加密只能用私钥解密、私钥加密只能用公钥解密
- 蟹老板用自己的私钥对信件进行加密，并发送给海绵宝宝
- 海绵宝宝使用蟹老板的公钥进行解密，获得原文
- 保证了**机密性、完整性和身份验证**

![image-20230413124750573](.\byte-images\image-20230413124750573.png)

> 下面一二点会形成套娃，所有我们最后需要有一个大哥站出来说够了，就到这里，这个大哥就是根证书，也就是套娃链(证书链)的尽头

![image-20230413125010339](.\byte-images\image-20230413125010339.png)

> PKI具体是什么？
>
> PKI（Public Key Infrastructure，公钥基础设施）是一种安全技术体系，用于管理和分发数字证书、公钥和私钥等密钥材料，以保证数字通信和电子商务中的安全性、可信性和可靠性。
>
> PKI 体系由以下几个组成部分构成：
>
> 1. 数字证书：数字证书是一种用于证明某个实体身份和公钥信息的电子凭证，由认证机构（CA）进行签发和管理。数字证书包括证书拥有者的身份信息、公钥、数字签名等信息，可以用于身份验证、数据加密和数字签名等场景。
> 2. 证书颁发机构（CA）：CA 是 PKI 体系的核心组成部分，负责签发、验证和管理数字证书。CA 通常是由信任机构或政府部门颁发，具有可信的身份和信誉，是数字证书可靠性的保证。
> 3. 注册机构（RA）：RA 是 CA 的辅助机构，负责验证证书申请者的身份信息和授权申请数字证书。
> 4. 数字签名：数字签名是一种用于验证数字证书有效性和真实性的技术，可以确保数据的完整性、不可否认性和真实性。
> 5. 证书撤销列表（CRL）：CRL 是由 CA 管理的一份撤销数字证书的列表，如果数字证书已经被撤销，则该数字证书将无法继续使用。
> 6. 证书存储库（CS）：CS 是用于存储数字证书和其他密钥材料的安全存储设施。
>
> PKI 是一种安全技术体系，用于管理和分发数字证书、公钥和私钥等密钥材料，以保证数字通信和电子商务中的安全性、可信性和可靠性。PKI 体系由数字证书、CA、RA、数字签名、CRL 和 CS 等组成部分构成，可以应用于身份验证、数据加密和数字签名等场景。

#### 证书链示例

![image-20230413125316616](.\byte-images\image-20230413125316616.png)

### HTTPS

![image-20230413125448151](.\byte-images\image-20230413125448151.png)

**小结**

- 网络安全三要素：**机密性、完整性和身份验证**
- 在没有提前交换秘密信息的前提下，无法在不安全的信道交换秘密信息
- PKI保证了普通用户不需要“面对面”和根证书机构交换根证书
- HTTPS使用PKI完成了除客户端身份验证以外的特性，客户端身份验证靠
- HTTP协议实现