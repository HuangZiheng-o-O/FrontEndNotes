# 小满面试题答案

> 答案来源：chatGPT4模型
>
> 关于小满的其他视频的原创完整笔记均配套存放在作者小余的GitHub中，需要可免费自取(没有任何额外条件)。登录不上GitHub的找视频作者UP主`小满zs`获取
>
> 小满面试题地址(无答案)：[interview/README.md at main · message163/interview (github.com)](https://github.com/message163/interview/blob/main/README.md)
>
> GitHub地址：[2002XiaoYu/Latest-front-end-Notes: 高质量编程百万字笔记之路--前后端 (github.com)](https://github.com/2002XiaoYu/Latest-front-end-Notes)

## HTML 的字符实体是什么

HTML 字符实体（Character Entities）是一种表示特殊字符的方法，它允许在 HTML 文档中插入那些在 HTML 语法中有特殊含义的字符，或者那些无法直接在键盘上输入的字符。字符实体以 "&" 符号开始，以 ";" 符号结束。

以下是一些常见的 HTML 字符实体：

1. `&lt;`：小于号（<）
2. `&gt`：大于号（>）
3. `&amp`：和号（&）
4. `&quot`：双引号（"）
5. `&apos`：单引号（'）
6. ` &nbsp;`：不间断空格（non-breaking space）

示例：

```html
htmlCopy code<p>10 &lt; 20</p> <!-- 显示为：10 < 20 -->
<p>if (x &amp;&amp; y) { ... }</p> <!-- 显示为：if (x && y) { ... } -->
<p>&quot;Hello, World!&quot;</p> <!-- 显示为："Hello, World!" -->
```

除了上述常见的字符实体，HTML 还支持许多其他字符实体，如版权符号（`&copy;`）、注册商标符号（`&reg;`）等。此外，还可以通过 Unicode 编码（如 `&#169` 表示 ©）来表示字符实体。

## js底层数据结构如何存储在V8里面

V8 引擎是 Google 开发的开源 JavaScript 引擎，用于 Chrome 浏览器和 Node.js 环境。它通过高度优化的数据结构和性能优化技术实现了快速的 JavaScript 代码执行。在 V8 引擎中，主要使用以下数据结构来存储 JavaScript 对象：

1. 堆（Heap）：V8 引擎使用堆来存储所有的 JavaScript 对象。堆是一个连续的内存区域，分为新生代（Young Generation）和老生代（Old Generation）两个区域。新生代区域用于存储生命周期较短的对象，老生代区域则用于存储生命周期较长的对象。这种划分有助于提高垃圾回收的效率。
2. 对象表示：在 V8 中，JavaScript 对象通过特定的数据结构表示，如 SMI（Small Integer）、Tagged Pointer 和 JSObject。SMI 表示 31 位整数，用于存储小整数。Tagged Pointer 表示一个指向堆中对象的指针，通过标签位（最后一位）来表示它是一个指针。JSObject 表示一个完整的 JavaScript 对象，包括属性、方法等。
3. 属性存储：对象的属性存储在两种不同的数据结构中：Named Property 和 Indexed Property。Named Property 是存储具有字符串键名的属性，通常使用哈希表或类似结构进行存储。Indexed Property 是存储具有整数键名的属性，通常使用类似数组的结构进行存储。
4. 隐藏类（Hidden Class）：为了优化属性访问速度，V8 引擎使用了一种称为隐藏类的技术。每个对象都有一个隐藏类，用于存储对象的结构信息（如属性名和属性位置）。当访问对象的属性时，V8 会利用隐藏类来快速定位属性值。
5. 内联缓存（Inline Cache，IC）：内联缓存是 V8 优化属性访问和方法调用的重要技术。通过缓存对象的隐藏类和属性访问信息，V8 能够避免重复执行相同的查找操作，从而提高代码执行速度。

总之，V8 引擎通过多种高度优化的数据结构和技术实现了高效的 JavaScript 对象存储和访问。

## H5新特性

HTML5 是一项广泛使用的 Web 标准，相较于之前的 HTML 版本，HTML5 带来了许多新特性和改进。以下是一些重要的 HTML5 新特性：

1. 语义化标签：HTML5 引入了一些新的语义化标签，如 `<header>`、`<nav>`、`<article>`、`<section>`、`<aside>` 和 `<footer>`，它们提供了更清晰的文档结构和便于搜索引擎理解。
2. 多媒体支持：HTML5 提供了对原生音频和视频的支持，通过 `<audio>` 和 `<video>` 标签可以轻松地在网页中嵌入音频和视频内容。这使得在网页中播放多媒体内容变得更加简单，无需依赖外部插件如 Flash。
3. 表单增强：HTML5 引入了许多新的输入类型（如 `email`、`tel`、`number` 等）和表单属性（如 `placeholder`、`required`、`pattern` 等），使得创建富有交互性的表单变得更容易。
4. 图形和动画：HTML5 提供了强大的图形和动画能力，如通过 `<canvas>` 标签可以在网页中绘制 2D 图形和动画，通过 WebGL 技术可以实现 3D 图形渲染。
5. 离线应用支持：HTML5 引入了 Application Cache（AppCache）和 Service Workers，使得 Web 应用可以在离线状态下运行，提高了用户体验。尤其是 Service Workers，它支持了强大的离线缓存、推送通知和后台同步等功能。
6. 地理位置：HTML5 的地理位置 API 允许开发者获取用户的地理位置信息，从而实现基于位置的服务和应用。
7. 本地存储：HTML5 提供了 Web Storage（包括 localStorage 和 sessionStorage）和 IndexedDB 数据库，使得 Web 应用可以在客户端存储大量数据，提高了应用性能和用户体验。
8. 文件 API：HTML5 引入了一系列文件处理 API，如 FileReader、FileWriter 等，使得 Web 应用可以在客户端处理本地文件，实现文件读取、写入等操作。
9. 拖放 API：HTML5 的拖放 API 允许开发者轻松地实现拖放功能，提高了 Web 应用的交互性。
10. Web Workers：Web Workers 允许开发者在 Web 应用中创建多线程，将耗时的任务放到后台线程中运行，避免阻塞主线程，提高了应用性能。

这些新特性使得 HTML5 成为了创建现代 Web 应用的强大工具，极大地提升了 Web 开发的能力和用户体验。HTML5 让开发者可以更加高效地构建功能丰富、交互性强、性能优秀的 Web 应用，同时也为移动端和桌面端提供了更一致的体验。

---

- **如果提到localstorage 就追问 localstorage API 以及 localStorage 实现原理 以及 localStorage 存在哪儿 以及localStorage 跨域**

`localStorage` 是 HTML5 引入的一种客户端存储技术，属于 Web Storage API 的一部分。它允许 Web 应用在浏览器端存储键值对（key-value pairs），具有较长的持久性和较大的存储空间。下面是关于 `localStorage` 的一些详细信息：

1. `localStorage` API：主要有以下几个方法：

   - `setItem(key, value)`: 用于存储数据，接受两个参数，一个是键（字符串），另一个是值（字符串）。
   - `getItem(key)`: 根据键获取存储的值，如果键不存在，则返回 `null`。
   - `removeItem(key)`: 根据键删除存储的数据。
   - `clear()`: 清除所有存储的数据。
   - `key(index)`: 根据索引获取存储的键，索引从0开始。如果索引无效，则返回 `null`。

   另外，`localStorage` 还具有 `length` 属性，表示存储的键值对数量。

2. `localStorage` **实现原理**：`localStorage` 是基于浏览器的实现，通常将数据存储在浏览器的专用存储区域。不同浏览器的存储方式可能有所不同，例如：硬盘文件、SQLite 数据库等。数据以键值对的形式存储，并且在不同的页面加载和浏览器重启之间保持持久性。

3. `localStorage` **存在哪儿**：如上所述，`localStorage` 数据通常存储在浏览器的专用存储区域。具体位置取决于浏览器和操作系统。例如，在 Chrome 浏览器中，可以在用户数据目录下找到名为 "Local Storage" 的文件夹，其中包含了以 `.localstorage` 为扩展名的文件，存储了 `localStorage` 数据。

4. `localStorage` **跨域**：`localStorage` 是基于同源策略的，即仅允许同一个域名下的页面访问。不同域名、协议或端口的页面之间不能直接访问彼此的 `localStorage`。如果需要在不同域名之间共享数据，可以使用其他方法，例如：通过 `postMessage` 进行通信或利用服务器端存储等。

总之，`localStorage` 是一种简单且高效的客户端存储技术，但由于同源策略的限制，不支持跨域访问。

---

- **如果提到PWA技术 就追问 PWA优点 继续追问 Service Workers 继续追问 PWA和hybrid的不同**

1. PWA 技术： Progressive Web Apps（PWA）是一种使用 Web 技术构建的应用，它具有原生应用的许多特性。PWA 通过一系列技术和设计原则来提供更好的用户体验，使 Web 应用具有原生应用的可靠性、速度和功能。
2. PWA 优点：
   - 可靠：借助 Service Workers，PWA 可以在脱机或弱网络环境下运行，提高应用的可用性。
   - 快速：PWA 使用预缓存和运行时缓存策略，减少网络延迟，使得应用加载和运行速度更快。
   - 可安装：用户可以将 PWA 添加到桌面或主屏幕，像原生应用一样访问。
   - 自动更新：PWA 可以实现静默更新，用户总是使用最新版本的应用。
   - 跨平台：PWA 可以在不同操作系统和设备上运行，提高开发效率。
   - 安全：PWA 需要通过 HTTPS 提供服务，保证数据安全和完整性。
   - 可发现：PWA 可以被搜索引擎爬取和索引，提高应用的可见性。
3. Service Workers： Service Workers 是 PWA 的核心技术之一，是一种在浏览器后台运行的 JavaScript 脚本。它可以拦截和处理网络请求，实现资源缓存和离线功能。Service Workers 运行在与网页独立的线程中，不会阻塞网页的主线程，使得 PWA 可以在脱机状态下工作，提高性能和可靠性。
4. PWA 与 Hybrid 的不同： PWA 和 Hybrid 应用都试图在 Web 应用和原生应用之间找到平衡。它们的主要区别在于技术实现和目标：
   - PWA：使用 Web 技术构建，旨在提供类似原生应用的用户体验。PWA 可以在浏览器中运行，或作为独立的应用添加到桌面或主屏幕。它主要依赖于 Service Workers 和其他 Web API 来实现离线功能、推送通知等特性。
   - Hybrid 应用：将 Web 应用嵌入到原生应用容器中，通常使用 WebView 组件。Hybrid 应用通过 JavaScript 和原生代码之间的桥接（如 Apache Cordova）来实现原生设备功能的访问。Hybrid 应用需要为每个平台构建和分发原生应用包，而 PWA 通过 Web 分发，无需应用商店。

总之，PWA 和 Hybrid 应用都试图提供更好的跨平台体验。PWA 主要依赖 Web 技术，通过 Service Workers 和其他 Web API 提供原生应用的可靠性、速度和功能，具有自动更新、可安装、安全等优点。而 Hybrid 应用将 Web 应用嵌入到原生应用容器中，使用 WebView 组件，通过 JavaScript 和原生代码之间的桥接来实现对原生设备功能的访问。PWA 可以直接通过 Web 分发，而 Hybrid 应用需要为每个平台构建和分发原生应用包。根据项目需求和目标，开发者可以选择 PWA 或 Hybrid 应用作为应用开发策略。

- **如果提到canvas 就追问 canvas 常用API**

`<canvas>` 是 HTML5 引入的一个元素，允许在网页上绘制图形和动画。通过 JavaScript，可以操作 canvas 上的 2D 绘图上下文（context），以实现丰富的图形绘制功能。以下是一些常用的 canvas API：

1. 获取 2D 绘图上下文：

   ```js
   javascriptCopy codeconst canvas = document.getElementById('myCanvas');
   const ctx = canvas.getContext('2d');
   ```

   首先获取 canvas 元素，然后通过 `getContext('2d')` 获取 2D 绘图上下文。

2. 绘制矩形：

   - `fillRect(x, y, width, height)`: 绘制一个填充的矩形，指定矩形左上角的坐标 (x, y) 以及宽度和高度。
   - `strokeRect(x, y, width, height)`: 绘制一个矩形轮廓，指定矩形左上角的坐标 (x, y) 以及宽度和高度。
   - `clearRect(x, y, width, height)`: 清除一个矩形区域，指定矩形左上角的坐标 (x, y) 以及宽度和高度。

3. 绘制路径：

   - `beginPath()`: 开始创建新路径。
   - `moveTo(x, y)`: 将画笔移动到指定坐标 (x, y)。
   - `lineTo(x, y)`: 从当前画笔位置绘制一条直线到指定坐标 (x, y)。
   - `arc(x, y, radius, startAngle, endAngle, [anticlockwise])`: 绘制一个圆弧，指定圆心坐标 (x, y)、半径、起始角度、结束角度，以及可选的绘制方向（默认顺时针，设置为 `true` 时逆时针）。
   - `closePath()`: 关闭当前路径，将当前画笔位置连接到路径的起始点。
   - `fill()`: 填充当前路径。
   - `stroke()`: 绘制当前路径的轮廓。

4. 设置样式：

   - `fillStyle`: 设置填充颜色、渐变或图案。
   - `strokeStyle`: 设置轮廓颜色、渐变或图案。
   - `globalAlpha`: 设置全局透明度。
   - `lineWidth`: 设置线条宽度。
   - `lineCap`: 设置线条端点样式（如 "butt"、"round"、"square"）。
   - `lineJoin`: 设置线条连接点样式（如 "miter"、"round"、"bevel"）。
   - `miterLimit`: 设置斜接长度限制。
   - `createLinearGradient(x0, y0, x1, y1)`: 创建一个线性渐变。
   - `createRadialGradient(x0, y0, r0, x1, y1, r1)`: 创建一个径向渐变。
   - `createPattern(image, repetition)`: 使用指定的图片、画布或视频帧创建一个图案。`repetition` 参数可以设置为 "repeat"（默认）、"repeat-x"、"repeat-y" 或 "no-repeat"。

5. 文字绘制：

   - `font`: 设置字体样式，如 "16px Arial"。
   - `textAlign`: 设置文本对齐方式，如 "start"、"end"、"left"、"right" 或 "center"。
   - `textBaseline`: 设置文本基线，如 "top"、"hanging"、"middle"、"alphabetic"（默认）、"ideographic" 或 "bottom"。
   - `fillText(text, x, y, [maxWidth])`: 在指定坐标 (x, y) 处填充文本。可选的 `maxWidth` 参数用于设置文本最大宽度。
   - `strokeText(text, x, y, [maxWidth])`: 在指定坐标 (x, y) 处绘制文本轮廓。可选的 `maxWidth` 参数用于设置文本最大宽度。
   - `measureText(text)`: 返回一个 TextMetrics 对象，包含指定文本的宽度、实际边界框等信息。

6. 变换与裁剪：

   - `translate(x, y)`: 平移坐标系。
   - `rotate(angle)`: 旋转坐标系，指定角度（弧度制）。
   - `scale(x, y)`: 缩放坐标系，指定水平和垂直缩放因子。
   - `transform(a, b, c, d, e, f)`: 应用一个 2D 矩阵变换，参数分别代表水平缩放、垂直倾斜、水平倾斜、垂直缩放、水平移动和垂直移动。
   - `setTransform(a, b, c, d, e, f)`: 使用一个 2D 矩阵变换替换当前的变换矩阵。
   - `resetTransform()`: 重置变换矩阵为单位矩阵，恢复到初始状态。
   - `clip()`: 使用当前路径作为裁剪区域。

7. 图像操作：

   - `drawImage(image, dx, dy, [dWidth, dHeight])`: 在画布上绘制图像。可以指定图像的目标位置 (dx, dy)，以及可选的目标宽度和高度（默认为图像原始宽度和高度）。

   - `createImageData(width, height)`: 创建一个新的、空白的 ImageData 对象，指定宽度和高度。

   - `getImageData(sx, sy, sw, sh)`: 获取画布上指定矩形区域的像素数据，返回一个 ImageData 对象。

   - `putImageData(imageData, dx, dy, [dirtyX, dirtyY, dirtyWidth, dirtyHeight])`: 将 ImageData 对象的像素数据绘制到画布上。可将 ImageData 对象的像素数据绘制到画布上。可以通过以下参数来实现：

     - `imageData`: 要绘制的 ImageData 对象。
     - `dx` 和 `dy`: 目标位置的坐标（画布上的 x 和 y 坐标）。
     - 可选的 `dirtyX` 和 `dirtyY`: 要绘制的子矩形区域的左上角坐标，相对于 ImageData 对象（默认为 0）。
     - 可选的 `dirtyWidth` 和 `dirtyHeight`: 要绘制的子矩形区域的宽度和高度（默认为 ImageData 对象的宽度和高度）。

     ```js
     //示例代码
     const canvas = document.getElementById('myCanvas');
     const ctx = canvas.getContext('2d');
     
     // 获取画布上指定矩形区域的像素数据
     const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
     
     // 在画布上绘制 ImageData 对象的像素数据（例如，在其他位置或进行修改后）
     ctx.putImageData(imageData, 50, 50);
     ```

     在这个例子中，我们首先获取了画布上指定矩形区域的像素数据（整个画布区域），然后将这些数据绘制到画布的其他位置（例如，向右和向下平移 50 像素）。当然，你还可以在绘制之前修改 ImageData 对象的像素数据，以实现图像处理效果。

- **如果提到webSocket 就追问 webSocket 的用法 以及手动实现ws协议 继续追问SSE技术 和 ws的区别**

WebSockets 是一种在单个 TCP 连接上进行全双工通信的协议，它允许在客户端和服务器之间进行实时数据传输和交换。WebSockets 通过一个标准的握手过程建立连接，然后允许客户端和服务器之间发送数据帧。WebSockets 通常用于实时数据推送和在线游戏等应用场景。

SSE (Server-Sent Events) 技术是另一种实现服务器向客户端发送实时事件的方法，它是一种基于 HTTP 的长轮询技术。在 SSE 中，服务器通过 HTTP 连接向客户端推送数据，客户端通过 EventSource API 接收数据。相比于 WebSockets，SSE 不需要在客户端和服务器之间建立全双工连接，因此更适合于服务器向客户端推送数据的场景。

关于手动实现 ws 协议，需要使用 Node.js 自带的 `net` 模块来创建 TCP 服务器和客户端，并按照 WebSocket 协议规范实现握手过程、数据帧格式等细节。这个过程相对繁琐，需要了解 WebSocket 协议的细节和 Node.js 的网络编程相关知识。

至于 WebSocket 和 SSE 的区别，主要有以下几点：

1. WebSocket 是一种双向通信协议，允许客户端和服务器之间互相发送消息，而 SSE 只支持服务器向客户端发送消息。
2. WebSocket 是建立在 TCP 连接之上的，相比于 SSE 的 HTTP 长轮询机制，它的通信效率更高。
3. SSE 的 API 更简单，只需要使用 EventSource 对象即可接收服务器推送的数据，而 WebSocket 需要处理更多的底层细节。

- **如果提到webWorker 就追问 webWorker 用法 以及实现原理**

1. Web Worker： Web Worker 是一种在浏览器中运行 JavaScript 脚本的技术，它允许在后台线程中执行代码，而不会影响主线程的执行。这样可以将耗时的计算任务放在 Web Worker 中执行，避免阻塞主线程，提高页面的响应性能。

2. Web Worker 的用法： 创建和使用 Web Worker 的基本步骤如下：

   ```javascript
   // 在主线程中创建一个 Web Worker
   const worker = new Worker('worker.js');
   
   // 向 Web Worker 发送消息
   worker.postMessage('Hello, Web Worker!');
   
   // 监听来自 Web Worker 的消息
   worker.addEventListener('message', (event) => {
       console.log('收到 Web Worker 消息:', event.data);
   });
   
   // 在 worker.js 文件中处理消息和执行任务
   self.addEventListener('message', (event) => {
       console.log('收到主线程消息:', event.data);
       // 执行任务
       const result = performSomeTask(event.data);
       // 将结果发送回主线程
       self.postMessage(result);
   });
   ```

   在这个例子中，我们在主线程中创建了一个 Web Worker，并通过 `postMessage` 方法向它发送了一条消息。然后，在 Web Worker 中，我们监听 `message` 事件，收到消息后执行一些任务，并将结果通过 `postMessage` 方法发送回主线程。

3. Web Worker 的实现原理： Web Worker 的实现原理是基于浏览器的多线程能力。当创建一个 Web Worker 时，浏览器会在后台创建一个新的线程来执行指定的 JavaScript 文件。这个新线程与主线程是完全隔离的，它们之间不能直接访问对方的变量或函数。为了实现通信，Web Worker 提供了 `postMessage` 方法和 `message` 事件来在主线程和 Worker 线程之间传递消息。这种消息传递机制基于事件驱动模型，避免了线程间的竞争和同步问题。

   需要注意的是，由于 Web Worker 运行在单独的线程中，它无法直接访问 DOM、Window 对象或其他与主线程相关的资源。因此，Web Worker 更适用于处理与 UI 无关的计算密集型任务。

## 如何区分强网弱网

在网络性能评估中，通常通过以下几个因素来区分强网和弱网：

1. 带宽（Bandwidth）：带宽是指网络中在单位时间内传输数据的能力。强网具有较高的带宽，数据传输速度快，而弱网则具有较低的带宽，数据传输速度慢。
2. 延迟（Latency）：延迟是指数据在网络中传输的时间。强网的延迟较低，数据从发送端到接收端所需的时间较短；弱网的延迟较高，数据传输时间较长。
3. 丢包率（Packet Loss）：丢包率是指在网络中传输过程中丢失数据包的比例。强网的丢包率较低，数据传输更可靠；弱网的丢包率较高，可能导致数据传输不稳定或失败。
4. 抖动（Jitter）：抖动是指网络传输延迟的波动。强网的抖动较小，数据传输稳定性较好；弱网的抖动较大，可能导致数据传输不稳定。

在实际应用中，可以通过网络性能测试工具（如 ping、traceroute 等）或者在应用程序中通过测量数据传输速度、延迟等指标来评估网络状况。对于弱网环境，可以采取一些优化措施，如数据压缩、缓存、预加载、自适应传输等，以提高应用的性能和可用性。

## 什么是灰度

灰度（Gray Scale），在软件开发和部署领域中，通常指灰度发布（Gray Scale Release）或者灰度测试（Gray Scale Testing）。灰度发布是一种逐步推出新版本软件的策略，通过将新版本的软件或功能仅部署到一部分用户，从而在真实环境中验证其性能、稳定性和兼容性。这样可以在不影响所有用户的情况下，发现并修复潜在的问题，降低发布风险。

灰度发布的步骤通常如下：

1. 选择一部分用户作为灰度用户。这些用户可能是内部测试人员、早期采用者或随机选取的一部分用户。
2. 将新版本的软件或功能部署给这些灰度用户，而其他用户仍然使用旧版本。
3. 收集灰度用户的使用数据、反馈和错误报告，分析新版本在实际使用中的性能、稳定性和兼容性。
4. 如果发现问题，修复后再次进行灰度发布。如果新版本在灰度阶段表现良好，可以逐步扩大发布范围，最终向所有用户发布。

灰度发布的优点：

1. 降低风险：在新版本完全发布之前，可以发现并修复潜在的问题，降低由于发布导致的故障风险。
2. 收集真实数据：灰度发布可以在真实环境中收集用户的使用数据和反馈，为优化产品提供依据。
3. 减少回滚成本：如果新版本出现严重问题，只需要回滚受影响的一部分用户，而不是所有用户。

灰度发布是一种有效的发布策略，尤其适用于大型软件系统和互联网应用，可以有效地降低发布风险、提高软件质量。

## async defer

`async` 和 `defer` 都是 HTML 中的 `<script>` 标签的属性，它们用于控制浏览器加载和执行外部 JavaScript 文件的方式。它们主要影响页面的加载和渲染性能。

1. 不带 `async` 和 `defer` 的 `<script>` 标签：

   当浏览器遇到一个没有 `async` 和 `defer` 属性的 `<script>` 标签时，它会立即请求并加载该脚本。在脚本加载和执行期间，页面的渲染将被阻塞。这可能会导致页面加载速度变慢，影响用户体验。

   ```html
   htmlCopy code
   <script src="script.js"></script>
   ```

2. 带有 `async` 属性的 `<script>` 标签：

   当浏览器遇到一个带有 `async` 属性的 `<script>` 标签时，它会异步加载脚本，不阻塞页面的渲染。但是，一旦脚本加载完成，页面的渲染将暂停，以便立即执行脚本。如果有多个 `async` 脚本，它们将按照加载完成的顺序执行，而不是按照文档中的顺序。

   ```html
   htmlCopy code
   <script async src="script.js"></script>
   ```

3. 带有 `defer` 属性的 `<script>` 标签：

   当浏览器遇到一个带有 `defer` 属性的 `<script>` 标签时，它会异步加载脚本，同时不阻塞页面的渲染。不过，与 `async` 不同，`defer` 脚本会在页面解析完成后（即 DOMContentLoaded 事件触发之前）按照它们在文档中的顺序执行。这样可以确保脚本之间的依赖关系得到正确处理。

   ```html
   htmlCopy code
   <script defer src="script.js"></script>
   ```

总结：

- 不带 `async` 和 `defer` 的脚本会阻塞页面的渲染，可能导致加载速度变慢。
- 带有 `async` 属性的脚本会异步加载和执行，不阻塞页面渲染，但执行顺序不确定。
- 带有 `defer` 属性的脚本会异步加载，页面解析完成后按照文档顺序执行，可以保证脚本之间的依赖关系。

在实际应用中，可以根据具体需求和脚本之间的依赖关系选择使用 `async` 或 `defer` 属性，以提高页面的加载性能和用户体验。

## SEO

SEO（Search Engine Optimization，搜索引擎优化）是一种通过对网站进行优化，提高网站在搜索引擎结果页面（SERP，Search Engine Results Page）排名的过程。高排名通常会为网站带来更多的流量和潜在用户。SEO 旨在使网站更易被搜索引擎抓取、索引和理解，从而提高其在搜索结果中的可见度。

SEO 可以分为两大类：

1. 内部优化（On-Page SEO）：内部优化是指对网站内容和结构进行优化，以便搜索引擎更容易抓取、索引和理解网站内容。主要包括：
   - 关键词策略：了解目标用户可能使用的关键词，合理地将关键词融入网站内容、标题、URL、meta 标签等。
   - 高质量内容：提供有价值、独特且相关的内容，以吸引和留住用户。
   - 语义标签：使用正确的 HTML 标签（如 h1、h2、p 等）对内容进行结构化，帮助搜索引擎理解页面内容的层次结构和重要性。
   - Meta 标签：使用合适的 meta 标签（如 title、description 等）描述页面内容，有助于提高搜索结果的点击率。
   - URL 结构：使用简洁、有意义的 URL 结构，有助于搜索引擎和用户理解页面内容。
   - 内部链接：合理地设置内部链接，帮助搜索引擎发现和索引网站的其他页面，同时提高用户体验。
   - 图片优化：使用 alt 属性描述图片内容，有助于搜索引擎理解图片内容，提高图片搜索的排名。
2. 外部优化（Off-Page SEO）：外部优化主要涉及到网站在互联网上的信誉和权威性。主要包括：
   - 反向链接（Backlinks）：其他网站链接到您的网站。高质量的反向链接可以提高您网站的权威性，从而提高搜索引擎排名。建立反向链接的方法有很多，如内容营销、社交媒体、友情链接、参与社区讨论等。
   - 社交媒体：在社交媒体平台上分享和推广您的内容，可以提高网站的知名度，吸引潜在用户和反向链接。
   - 在线评价和口碑：积极参与在线评价和口碑营销，提高您的网站在搜索引擎中的信誉和排名。

通过执行有效的 SEO 策略，您可以提高网站在搜索引擎中的排名，从而为您的网站带来以下好处：

1. 更多流量：通过提高搜索引擎排名，您的网站将获得更高的可见度，从而吸引更多潜在用户。这些用户通过搜索引擎找到您的网站，可能会成为您的客户或订阅者。
2. 更高的品牌知名度：排名靠前的网站往往被认为是权威和值得信赖的。当您的网站在搜索引擎中排名靠前时，用户更容易记住您的品牌和网站，从而提高品牌知名度和信誉。
3. 提高转化率：优化后的网站通常具有更好的用户体验、更高的页面加载速度和更清晰的信息结构。这些因素可以帮助留住访问者，并提高他们在您的网站上执行操作（如购买、注册或订阅）的可能性。
4. 更高的投资回报率（ROI）：与传统的广告方式相比，SEO 通常具有更高的投资回报率。通过优化网站，您可以在搜索引擎中吸引目标受众，从而实现更高的转化率和更长的客户留存时间。
5. 节省广告预算：当您的网站在搜索引擎中排名靠前时，您可以减少对付费广告的依赖，从而节省广告预算。自然排名通常被认为比付费广告更可信，因此可能会吸引更多潜在客户。
6. 提高竞争优势：当您的网站在搜索引擎中排名靠前时，您的竞争对手可能会在搜索结果中排名较低。这意味着您有更多的机会吸引潜在客户，从而在竞争中占据优势。

综上所述，执行有效的 SEO 策略可以为您的网站带来更多流量、提高品牌知名度、提高转化率、节省广告预算并提高竞争优势。这些好处将有助于实现您的业务目标，如增加销售、提高客户满意度和扩大市场份额。

## BFC

BFC（Block Formatting Context，块级格式化上下文）是一个独立的渲染区域，其中的元素遵循特定的布局规则。它主要影响着元素的布局和浮动元素的相互影响。BFC 在 CSS 布局中起着重要作用，理解 BFC 对于掌握布局技巧至关重要。

BFC 的特性：

1. 内部的块级元素会在垂直方向上一个接一个地排列。相邻的块级元素之间的垂直间距由它们的外边距（margin）决定，可能会发生外边距折叠现象。
2. BFC 区域不会与浮动元素重叠。在 BFC 中，浮动元素会被包含在计算高度内，这对于清除浮动（clearfix）非常有用。
3. BFC 是一个独立的容器，它的内部元素不会影响到外部元素，反之亦然。
4. BFC 元素的宽度会尽可能地填充其父元素，形成一个“自适应”效果。

如何创建一个 BFC：

以下 CSS 属性可以用于创建一个新的 BFC：

1. `overflow`：除了 `visible` 之外的任何值（如 `hidden`、`auto`、`scroll`）。
2. `display`：值为 `flex`、`grid`、`table` 或 `inline-block`。
3. `position`：值为 `absolute` 或 `fixed`。
4. `float`：值为 `left` 或 `right`。

应用场景：

1. 清除浮动：在父元素上应用 `overflow: hidden` 或 `overflow: auto` 可以创建一个新的 BFC，防止子元素的浮动对其他元素产生影响。
2. 防止外边距折叠：当两个相邻的块级元素具有相同的垂直外边距时，可以创建一个新的 BFC 来防止它们的外边距折叠。
3. 自适应布局：在需要自适应宽度的布局中，可以利用 BFC 的特性使元素尽可能地填充其父元素。

了解 BFC 可以帮助您更好地理解和掌握 CSS 布局，解决布局中的各种问题，如清除浮动、外边距折叠和自适应布局等。

## 回流与重绘 以及优化方案

回流（reflow）和重绘（repaint）是浏览器渲染过程中的两个关键概念。当 DOM 结构、元素位置、大小等发生变化时，浏览器需要重新计算布局并渲染页面，这个过程可能导致性能问题。了解回流和重绘有助于优化网页性能。

回流：当元素的布局、几何属性（如宽度、高度、位置等）发生改变时，浏览器需要重新计算元素的布局。这个过程称为回流。回流可能由以下原因触发：

1. 添加或删除可见的 DOM 元素。
2. 元素尺寸变化，如改变宽度、高度、边距等。
3. 内容改变，如文本改变或图片大小调整。
4. 页面初始化渲染。
5. 激活 CSS 伪类，如:hover。
6. 修改浏览器窗口尺寸。

重绘：当元素的视觉属性（如颜色、背景等）发生改变，但布局未发生变化时，浏览器需要重新绘制元素。这个过程称为重绘。

优化方案：

1. 避免频繁操作 DOM。可以将需要多次修改的 DOM 操作合并到一个文档片段（DocumentFragment）中，然后一次性将其添加到 DOM 树中。
2. 使用 CSS3 动画替代 JavaScript 动画。CSS3 动画由浏览器优化，性能更好。
3. 使用 `requestAnimationFrame` 替代 `setTimeout` 或 `setInterval` 进行动画控制，以实现更高效的帧率控制。
4. 避免使用表格布局，因为表格中的一个小改动可能导致整个表格回流。
5. 将需要频繁回流和重绘的元素设置为绝对定位或固定定位，以减少对其他元素的影响。
6. 避免使用 JavaScript 计算布局信息。如果必须使用，请缓存结果，以减少回流和重绘次数。
7. 在修改样式时，尽量一次性修改多个样式属性。可以通过修改元素的 `className` 或使用 CSS 文本（如 `element.style.cssText`）实现。

总之，减少回流和重绘次数可以显著提高网页性能。通过了解回流和重绘的原因以及优化方案，您可以为用户提供更流畅的浏览体验。

## webComponents 以及 微前端 以及 emp 模块联邦

Web Components： Web Components 是一组用于创建可重用、封装的 HTML 元素的 Web 技术。它们可以让您创建自定义、可重用的组件，这些组件在不同的 Web 应用程序中都能正常运行。Web Components 主要由以下三个技术组成：

1. Custom Elements：允许您创建自定义的 HTML 元素，以扩展现有的 HTML 元素或创建全新的元素。自定义元素可以具有自己的行为和样式。
2. Shadow DOM：为自定义元素提供封装。通过使用 Shadow DOM，您可以将元素的结构、样式和行为封装在一个独立的作用域中，防止样式和脚本污染。
3. HTML Templates：允许您创建可重用的 HTML 模板，这些模板在页面加载时不会被渲染，而是在运行时根据需要激活和使用。

微前端（Micro Frontends）： 微前端是一种将大型前端应用程序分解为更小、可独立开发和部署的组件的架构方法。它将后端微服务的概念扩展到前端开发。微前端的目标是提高开发效率、降低维护成本并提供更好的可扩展性。它可以让团队按功能或业务领域划分，独立开发和部署各自负责的前端组件。

EMP（模块联邦）： EMP 是指基于 Webpack 5 Module Federation（模块联邦）的微前端解决方案。Webpack 5 的模块联邦允许在不同的构建之间动态地共享和使用模块。这对于微前端架构非常有用，因为它允许不同的前端应用程序共享相同的依赖，避免重复下载和加载。

模块联邦的主要特点包括：

1. 动态导入：在运行时按需加载其他应用程序的代码。
2. 高效的依赖共享：不同的前端应用程序可以共享相同的依赖，避免重复下载。
3. 独立开发和部署：每个前端应用程序可以独立开发、构建和部署，降低对整个系统的影响。
4. 兼容性：支持与现有技术栈（如 React、Vue 等）的集成。

总结，Web Components 提供了创建封装、可重用的 Web 组件的方法；微前端架构可以帮助您将大型前端应用程序拆分为更小、可独立开发和部署的组件；而 EMP（基于Webpack 5 的模块联邦）是一种实现微前端的有效解决方案，允许在不同的构建之间动态地共享和使用模块。EMP 可以让不同的前端应用程序共享相同的依赖，从而避免了重复下载和加载。它还支持动态导入，可以在运行时按需加载其他应用程序的代码。使用 EMP，每个前端应用程序可以独立开发、构建和部署，降低对整个系统的影响。同时，EMP 也兼容现有的技术栈，如 React、Vue 等，便于开发者集成和使用。总之，EMP 是一种可靠的微前端实现方案，可以帮助开发者提高项目的可维护性和可扩展性。

## Css盒模型 和 怪异盒模型区别 以及统一策略

CSS 盒模型（Box Model）定义了一个 HTML 元素在页面上占据的空间。在标准盒模型下，一个 HTML 元素的大小由其内容区域、内边距（padding）、边框（border）和外边距（margin）决定，而在怪异盒模型下，一个 HTML 元素的大小不包括内边距和边框，而是包括外边距。

标准盒模型下，一个 HTML 元素的大小可以通过以下公式计算：

```javascript
element size = content width/height + padding + border + margin
```

而在怪异盒模型下，一个 HTML 元素的大小只包括其内容区域和外边距，不包括内边距和边框。

为了解决盒模型的兼容性问题，CSS 提供了一个 `box-sizing` 属性，可以用来指定盒模型的计算方式。`box-sizing` 属性有两个可选值：

1. `content-box`（标准盒模型）：元素的宽度和高度只包括内容区域，不包括内边距、边框和外边距。
2. `border-box`（怪异盒模型）：元素的宽度和高度包括内容区域、内边距和边框，但不包括外边距。

通常情况下，推荐使用 `border-box` 进行盒模型的计算，因为它能更好地控制元素的大小和位置，减少布局问题的发生。

如果需要将页面中的所有元素都设置为相同的盒模型计算方式，可以在全局样式表中添加以下代码：

```javascript
*, *::before, *::after {
  box-sizing: border-box;
}
```

这个通配符选择器将影响页面中的所有元素及其伪元素，将它们的盒模型计算方式统一为 `border-box`，从而避免了不同盒模型之间的兼容性问题。

## css 伪类

CSS 伪类（Pseudo-classes）是一种选择器，用于在某些特定状态下选取 HTML 元素。它们在选择器列表中以单冒号（:）开头。下面是一些常见的 CSS 伪类：

1. `:hover`：当用户将鼠标悬停在元素上时，应用样式。
2. `:active`：当元素被激活（如被点击）时，应用样式。
3. `:focus`：当元素获得焦点时，应用样式。适用于可聚焦元素，如 input、button 等。
4. `:checked`：当复选框或单选框被选中时，应用样式。
5. `:nth-child(n)`：选取父元素下的第 n 个子元素。
6. `:first-child`：选取父元素下的第一个子元素。
7. `:last-child`：选取父元素下的最后一个子元素。
8. `:not(selector)`：选取不匹配特定选择器的元素。
9. `:nth-of-type(n)`：选取指定类型的第 n 个子元素。
10. `:first-of-type`：选取指定类型的第一个子元素。
11. `:last-of-type`：选取指定类型的最后一个子元素。
12. `:empty`：选取没有子元素的元素。
13. `:target`：选取当前活动的锚点链接（anchor link）所指向的元素。

伪类可以很好地扩展 CSS 选择器的功能，使得我们可以更精确地选取和操作 HTML 元素。了解伪类的用法和语法规则可以帮助我们更好地掌握 CSS 的使用。

## 为什么哔哩哔哩用vmin 不用 vh

哔哩哔哩（Bilibili）作为一个视频网站，其网页内容往往需要在不同的设备上显示，而且用户可能会在不同的浏览器和操作系统上访问网站。因此，为了保证网页的可访问性和响应式设计，网站需要使用一种跨平台的单位来进行布局和样式设置。

在此背景下，哔哩哔哩选择了 `vmin` 作为布局单位，而不是 `vh`。`vmin` 是一个相对单位，它根据当前视口的宽度和高度中较小的一个来进行计算。而 `vh` 则是相对于视口高度的单位，这意味着在某些设备上，页面布局可能会因为视口高度不同而出现问题。

使用 `vmin` 单位可以更好地适应不同设备的屏幕大小，确保页面布局在各种设备上都能正常显示。另外，使用 `vmin` 也能够让哔哩哔哩更好地控制页面元素的大小和位置，避免出现布局问题和样式失调的情况。

需要注意的是，`vmin` 单位适用于那些需要在不同设备上呈现相同比例的元素，如图片、视频等。而对于需要基于视口高度进行定位和布局的元素，还是应该使用 `vh` 单位。

## css变量

CSS 变量（CSS Variables），又称为自定义属性（Custom Properties），是 CSS3 中新增的一种特性。它允许开发者在 CSS 中定义自己的变量，并且可以在样式表中的任何地方使用这些变量。CSS 变量以 `--` 开头，后面跟着变量名和变量值，语法格式如下：

```css
:root {
  --main-color: #ff0000;
}
```

在上面的示例中，我们定义了一个名为 `--main-color` 的变量，并将其值设置为红色。为了使用这个变量，我们可以在 CSS 规则中使用 `var()` 函数来调用它，如下所示：

```css
h1 {
  color: var(--main-color);
}
```

使用 CSS 变量可以带来以下好处：

1. 提高代码的可维护性：使用变量可以减少代码中的硬编码，让样式更易于维护和修改。
2. 提高代码的重用性：变量可以在多个地方使用，从而减少代码的重复。
3. 提高样式的灵活性：变量可以根据需要进行修改，从而改变整个页面的样式。
4. 简化开发流程：变量可以通过 JavaScript 动态生成和修改，从而实现更加灵活和高效的开发流程。

需要注意的是，CSS 变量的浏览器兼容性还不完善，不同浏览器对其的支持程度有所不同。在使用 CSS 变量时，需要谨慎考虑其兼容性问题，并进行适当的兼容性处理。

## css flex grid

CSS 中的 Flex 布局和 Grid 布局都是比较流行的现代化布局方式。

Flex 布局是一种基于弹性盒子模型的布局方式，它可以让容器中的子元素具有更加灵活和自适应的排列方式。在 Flex 布局中，我们可以通过设置容器的 `display: flex` 来开启 Flex 布局，然后通过设置 `flex-direction`、`justify-content`、`align-items`、`align-self` 等属性来控制子元素的排列方式。

Grid 布局则是一种基于网格布局的方式，它可以让我们更加方便地控制页面布局。在 Grid 布局中，我们可以将容器分成若干行和列，然后通过设置 `grid-template-columns`、`grid-template-rows`、`grid-column`、`grid-row` 等属性来控制子元素在网格中的位置和大小。

相比之下，Flex 布局更适合于简单的布局和排列方式，例如导航栏、列表等；而 Grid 布局则更适合于复杂的布局，例如多列文章布局、图片墙等。

需要注意的是，Flex 布局和 Grid 布局都需要考虑浏览器的兼容性问题。在使用这些布局方式时，我们需要了解它们的兼容性情况，并进行相应的兼容性处理。此外，为了更好地使用 Flex 布局和 Grid 布局，我们也需要了解它们的语法和用法，以及如何使用它们来实现各种复杂的页面布局。

## Css 动画 关键帧等

CSS 动画是一种通过 CSS 属性和关键帧来实现动态效果的方式。在 CSS 中，我们可以通过 `animation` 属性来创建动画，并通过关键帧来指定动画的具体效果。

关键帧（Keyframes）是 CSS 动画中的一个重要概念，它用于指定动画在不同时间点上的状态和属性值。在 CSS 中，我们可以通过 `@keyframes` 规则来定义关键帧，例如：

```css
@keyframes myanimation {
  0% {
    transform: translateX(0);
  }
  50% {
    transform: translateX(50px);
  }
  100% {
    transform: translateX(100px);
  }
}
```

在上面的示例中，我们定义了一个名为 `myanimation` 的动画，它在动画的开始、中间和结束时分别将元素向右移动 0、50 和 100 个像素。

除了关键帧外，我们还可以使用 `animation` 属性来指定动画的持续时间、重复次数、延迟时间等属性。例如：

```css
.box {
  animation: myanimation 2s ease-in-out infinite;
}
```

在上面的示例中，我们将 `myanimation` 动画应用到了 `.box` 元素上，并设置了动画的持续时间为 2 秒，缓动函数为 `ease-in-out`，重复次数为无限次。

除了使用 `animation` 属性外，我们还可以通过 `transition` 属性来实现简单的动态效果，例如渐变、缩放、旋转等。`transition` 属性可以让元素在状态变化时平滑地过渡到新状态，从而实现动态效果。

需要注意的是，在使用 CSS 动画时，我们需要考虑性能问题。由于动画可能会导致页面的重绘和重排，因此我们需要尽量避免频繁地进行动画操作，并尽可能地使用硬件加速来提高动画的性能和流畅度。

## 如果需要手动写动画，你认为最小时间间隔是多久，为什么？

 答：多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms＝16.7ms(前面这句话是小满答案，后面的不是)

如果需要手动写动画，最小时间间隔应该为 16 毫秒（即每秒 60 帧），这是因为：

1. 人眼的视觉暂留效应（Persistence of Vision）：当画面的变化速度超过每秒 60 帧时，人眼就难以感知到画面的变化。因此，为了保证动画的流畅度，我们应该尽量让动画的帧率达到 60 帧。
2. 浏览器的渲染机制：浏览器的渲染是一个复杂的过程，包括布局计算、样式计算、绘制和合成等多个阶段。为了保证动画的流畅度，我们需要让浏览器有足够的时间来完成每个阶段的工作。根据浏览器的渲染机制，每次渲染的最小时间间隔约为 16 毫秒。

因此，最小时间间隔应该为 16 毫秒。当然，对于一些比较简单的动画，比如平移、旋转等，我们可以适当降低帧率，以减少 CPU 和 GPU 的资源占用。但是对于一些比较复杂的动画，比如矩阵变换、变形等，我们应该尽量保持帧率在 60 帧左右，以保证动画的流畅度和质量。

## less scss 解决了什么问题

LESS 和 SCSS 是两种常见的 CSS 预处理器，它们通过引入变量、函数、嵌套规则等特性来扩展 CSS 的功能。

LESS 和 SCSS 解决了 CSS 的一些问题，包括：

1. 变量管理：LESS 和 SCSS 支持定义变量，并通过变量来管理颜色、字体、间距等属性。这使得样式的修改更加方便和快捷。
2. 嵌套规则：LESS 和 SCSS 支持嵌套规则，使得样式的层级关系更加清晰和易于理解。同时，通过嵌套规则，我们可以避免样式的重复书写，提高样式表的可读性和可维护性。
3. 混合（Mixin）和继承：LESS 和 SCSS 支持定义混合和继承规则，可以将常用的样式封装成函数或类，并在需要的地方进行调用和继承。这样可以提高代码的复用性和可维护性，同时也可以减少样式表的大小。
4. 运算和函数：LESS 和 SCSS 支持对数值和颜色进行运算，并提供了一些常用的函数，如 darken()、lighten()、saturate()、desaturate() 等。这些特性可以帮助我们快速计算出需要的属性值。

总的来说，LESS 和 SCSS 通过引入一些新的特性和语法，使得 CSS 更加灵活、可维护和易于扩展。同时，它们还提高了开发效率，减少了样式表的代码量，提高了样式表的可读性和可维护性。

## postCss 是干嘛的 是否用过 是否写过插件

PostCSS 是一款基于 JavaScript 的 CSS 处理器，它通过解析 CSS 文件并应用各种插件来增强 CSS 的功能。

PostCSS 提供了一些常用的插件，如自动添加浏览器前缀、变量替换、媒体查询合并等，同时还支持自定义插件来扩展其功能。

我曾经使用 PostCSS 来优化 CSS 的处理过程，并应用了一些插件来增强 CSS 的功能。例如，我使用了 `autoprefixer` 插件来自动添加浏览器前缀，使用了 `cssnano` 插件来压缩和优化 CSS 代码，还使用了 `postcss-px-to-viewport` 插件将像素单位转换为 vw/vh 单位，以适配不同的屏幕尺寸。

我也曾经写过自定义的 PostCSS 插件，用于实现一些特定的需求。例如，我曾经编写过一个插件，用于在 CSS 中引用 SVG 图像，并将 SVG 图像转换为 base64 编码。这个插件可以帮助我们减少 HTTP 请求，提高页面的加载速度。

总的来说，PostCSS 可以帮助我们提高 CSS 的开发效率，增强 CSS 的功能，并提高页面的性能和体验。

## 是否用过tailwindCss 是否用过unoCss

我熟悉 Tailwind CSS，但是我没有使用过 Uno.css。

Tailwind CSS 是一款 CSS 框架，它通过提供一组预定义的样式类来加速 UI 开发，减少 CSS 代码的重复性。Tailwind CSS 的样式类命名规则基于功能（而非视觉样式），例如 `text-center`、`bg-gray-300`、`w-1/2` 等。开发者可以将这些样式类应用到 HTML 元素上，从而快速创建出具有一致性和可复用性的 UI 组件。

Tailwind CSS 提供了丰富的样式类和配置选项，可以满足不同的 UI 设计需求。同时，它还提供了一些工具类和插件，如响应式设计、主题定制、动画效果等，可以帮助开发者更快地实现各种 UI 效果。

Uno.css 是另外一款 CSS 框架，它也提供了一组预定义的样式类，但是它的命名规则更加简洁和易于记忆。Uno.css 也支持响应式设计、主题定制、动画效果等特性。

虽然我没有使用过 Uno.css，但是根据了解，Uno.css 和 Tailwind CSS 在功能和特性上有一些相似之处。它们都可以帮助开发者快速实现一致性的 UI 设计，并提供了一些方便的工具类和插件，可以加速 UI 的开发和定制。

## typeOf null 是什么 原因是什么

在 JavaScript 中，`typeof null` 返回的是 `"object"`。

这是由于历史原因导致的。在 JavaScript 的早期版本中，`null` 被赋予了一个值，表示空对象指针。由于 JavaScript 是一种弱类型语言，它使用类型标签来区分不同的数据类型。在这个类型标签中，`null` 被归类为对象类型。因此，当使用 `typeof` 操作符检测 `null` 类型时，它会返回 `"object"`。

这个行为被认为是一种设计缺陷，并且在后来的 ECMAScript 规范中没有被修改。因此，`typeof null` 返回 `"object"` 是 JavaScript 的一个特殊行为。需要注意的是，这个行为只适用于 `null` 类型，对于其他的数据类型，`typeof` 操作符仍然会返回正确的类型。

需要注意的是，由于 `null` 被归类为对象类型，因此对 `null` 执行类似于访问对象属性的操作（例如 `null.prop` 或 `null.method()`）会导致 `TypeError` 错误。这个错误提示说明不能对 `null` 执行对象操作，因为它不是一个对象。

## 比较两个对象是否相等

在 JavaScript 中，比较两个对象是否相等是一个比较复杂的问题。这是因为对象是引用类型，在进行比较时，比较的是它们的引用地址，而不是对象的内容。如果两个对象的引用地址不同，那么它们就不相等，即使它们的属性值完全一致。

在实际开发中，比较两个对象是否相等有多种方法，下面介绍其中的几种常见方法。

1. 使用 JSON.stringify 方法

可以使用 `JSON.stringify()` 方法将对象序列化为 JSON 字符串，然后比较两个字符串是否相等。例如：

```javascript
const obj1 = { a: 1, b: 2 };
const obj2 = { b: 2, a: 1 };
const isEqual = JSON.stringify(obj1) === JSON.stringify(obj2);
console.log(isEqual); // true
```

需要注意的是，这种方法的局限性是它不能比较对象中的函数，因为 JSON 不支持函数序列化。

1. 使用 Lodash 库

Lodash 是一个 JavaScript 工具库，它提供了一系列实用的函数，包括比较对象是否相等的函数 `isEqual()`。例如：

```javascript
const obj1 = { a: 1, b: 2 };
const obj2 = { b: 2, a: 1 };
const isEqual = _.isEqual(obj1, obj2);
console.log(isEqual); // true
```

需要注意的是，Lodash 的 `isEqual()` 函数可以比较对象中的函数。

1. 递归比较对象属性

可以编写一个递归函数，用于比较两个对象的属性是否相等。例如：

```javascript
codefunction deepEqual(obj1, obj2) {
  if (obj1 === obj2) {
    return true;
  }
  if (typeof obj1 !== 'object' || obj1 === null ||
      typeof obj2 !== 'object' || obj2 === null) {
    return false;
  }
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  for (let key of keys1) {
    if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {
      return false;
    }
  }
  return true;
}

const obj1 = { a: 1, b: { c: 2 } };
const obj2 = { b: { c: 2 }, a: 1 };
const isEqual = deepEqual(obj1, obj2);
console.log(isEqual); // true
```

这个方法会递归比较两个对象的每个属性值，直到发现不相等的属性或者比较完所有属性。需要注意的是，这个方法不能比较对象中的循环引用，否则会导致死循环。

## 判断是不是数组

在 JavaScript 中，可以使用 Array.isArray() 方法来判断一个变量是否为数组。

例如，可以使用以下代码判断一个变量是否为数组：

```javascript
const arr = [1, 2, 3];
console.log(Array.isArray(arr)); // true

const obj = { a: 1, b: 2 };
console.log(Array.isArray(obj)); // false
```

在上面的代码中，使用 Array.isArray() 方法来判断变量 arr 是否为数组。由于 arr 是数组，因此该方法返回 true。然后，使用该方法来判断变量 obj 是否为数组，由于 obj 不是数组，因此该方法返回 false。

注意，typeof 运算符无法判断一个变量是否为数组。例如，使用 typeof 运算符来判断一个数组会返回 'object'，这是因为数组在 JavaScript 中被视为一种特殊的对象。因此，应该使用 Array.isArray() 方法来判断一个变量是否为数组。

## 说说常用的es6

ECMAScript 6 (ES6)，也称为 ECMAScript 2015，是 JavaScript 的一个重要版本。它引入了许多新的特性和语法，以使 JavaScript 语言更加现代化、高效和易于编写。下面是 ES6 中一些常用的特性：

1. 箭头函数

ES6 中的箭头函数是一种更简洁的函数语法，它可以更方便地定义函数表达式，同时可以避免 `this` 绑定问题。例如：

```javascript
const add = (a, b) => a + b;
console.log(add(1, 2)); // 3
```

1. let 和 const 声明

ES6 引入了 `let` 和 `const` 声明，用于声明块级作用域的变量和常量。它们与传统的 `var` 声明不同，不会受到变量提升和函数作用域的影响，可以更好地管理作用域和变量生命周期。例如：

```javascript
let a = 1;
const b = 2;
if (true) {
  let a = 3;
  const b = 4;
  console.log(a, b); // 3, 4
}
console.log(a, b); // 1, 2
```

1. 模板字符串

ES6 引入了模板字符串，用于更方便地拼接字符串和嵌入表达式。模板字符串使用反引号（`）包围字符串，表达式可以用 `${}` 语法嵌入其中。例如：

```javascript
const name = 'Tom';
const age = 18;
const message = `My name is ${name}, and I am ${age} years old.`;
console.log(message); // "My name is Tom, and I am 18 years old."
```

1. 解构赋值

ES6 引入了解构赋值语法，用于从数组或对象中提取值并赋给变量，可以更简洁地访问和使用数据。例如：

```javascript
const [a, b] = [1, 2];
console.log(a, b); // 1, 2

const { x, y } = { x: 3, y: 4 };
console.log(x, y); // 3, 4
```

1. 类和继承

ES6 引入了类和继承语法，使得 JavaScript 更加面向对象化。类和继承可以更方便地定义和组织代码，并且具有更好的封装性和可维护性。例如：

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

class Dog extends Animal {
  speak() {
    console.log(`${this.name} barks.`);
  }
}

const dog = new Dog('Rufus');
dog.speak(); // "Rufus barks."
```

这些是 ES6 中的一些常用特性，当然还有很多其他特性，例如模块化、迭代器、生成器

## proxy Reflect 为什么要配合 proxy劫持 函数 劫持for in

`Proxy` 是 ES6 引入的一种新的对象，它可以对对象进行拦截和定制，为开发者提供了一种强大的元编程（meta-programming）能力。

`Reflect` 是一个 JavaScript 内置对象，它提供了一组与 `Proxy` 对象相关的方法，用于操作对象的默认行为。

在 JavaScript 中，对象的属性和方法默认行为可以被覆盖或修改，这对于编写高级代码或框架非常有用。例如，可以使用 `Proxy` 对象拦截对象的读写、调用、属性枚举等操作，从而实现自定义逻辑。

下面是一些常见的使用场景：

1. 函数劫持

可以使用 `Proxy` 对象劫持函数的调用，从而实现自定义的行为。例如，可以用 `Proxy` 对象实现函数的缓存、延迟调用、参数验证等功能。

```javascript
function createCachedFunction(fn) {
  const cache = new Map();
  return new Proxy(fn, {
    apply(target, thisArg, args) {
      const key = JSON.stringify(args);
      if (cache.has(key)) {
        return cache.get(key);
      }
      const result = target.apply(thisArg, args);
      cache.set(key, result);
      return result;
    },
  });
}

const add = createCachedFunction((a, b) => {
  console.log('Computing...');
  return a + b;
});

console.log(add(1, 2)); // Computing... 3
console.log(add(1, 2)); // 3 (from cache)

```

1. 对象劫持

可以使用 `Proxy` 对象劫持对象的读写和属性枚举，从而实现自定义的行为。例如，可以用 `Proxy` 对象实现对象的深度克隆、对象的部分属性只读、对象的动态属性等功能。

```javascript
const data = { name: 'Tom', age: 18 };
const readOnlyData = new Proxy(data, {
  get(target, key, receiver) {
    if (key in target) {
      return target[key];
    }
    throw new Error(`Property "${key}" not found.`);
  },
  set(target, key, value, receiver) {
    throw new Error(`Property "${key}" is read-only.`);
  },
});

console.log(readOnlyData.name); // "Tom"
console.log(readOnlyData.age); // 18
console.log(readOnlyData.gender); // Error: Property "gender" not found.

readOnlyData.name = 'Jerry'; // Error: Property "name" is read-only.

```

1. `for...in` 枚举劫持

可以使用 `Reflect` 对象劫持 `for...in` 枚举操作，从而实现自定义的行为。例如，可以用 `Reflect` 对象实现枚举只读属性、隐藏某些属性等功能。

```javascript
const data = { name: 'Tom', age: 18 };
const readOnlyData = new Proxy(data, {
  ownKeys(target) {
    return Object.keys(target).filter((key) => key !== 'age');
  },
  get(target, key, receiver) {
    if (key === 'age') {
      return 'unknown';
    }
    return Reflect.get

```



## 迭代器 生成器 for of 以及 Iterator 以及数组解构原理 和对象解构原理（深入V8引擎）

迭代器（Iterator）和生成器（Generator）是 ES6 中新增的两个特性。

迭代器是一种机制，用于提供一种方法来访问集合中的每个元素，而不必暴露其内部实现。每个迭代器对象都包含一个 next() 方法，用于返回下一个元素，并标记集合的结尾。如果已经到达结尾，则返回一个包含 done 属性的对象。

生成器是一种特殊的函数，它可以通过使用关键字 yield 来暂停函数的执行，并返回一个值给调用方。生成器可以用于异步操作、延迟执行、流式处理等场景。

在 JavaScript 中，数组和对象解构是一种快速、方便的方式，用于将数组或对象的值解构到变量中。数组解构和对象解构都可以使用迭代器和生成器。

数组解构原理：

数组解构的本质是使用迭代器（Iterator）来遍历数组，并将其值赋给对应的变量。例如，可以将 [a, b, c] 解构为以下代码：

```javascript
const array = [1, 2, 3];
const iterator = array[Symbol.iterator]();
const a = iterator.next().value;
const b = iterator.next().value;
const c = iterator.next().value;
```

这里使用了数组的迭代器来遍历数组，并将其值赋给变量 a、b、c。如果数组的长度不足，则变量的值为 undefined。

对象解构原理：

对象解构的本质是使用对象的属性访问器来获取属性的值，并将其赋给对应的变量。例如，可以将 {x, y, z} 解构为以下代码：

```javascript
const obj = { x: 1, y: 2, z: 3 };
const x = obj.x;
const y = obj.y;
const z = obj.z;
```

这里使用了对象的属性访问器来获取属性的值，并将其赋给变量 x、y、z。如果属性不存在，则变量的值为 undefined。

在 V8 引擎中，数组解构和对象解构的实现都使用了迭代器和属性访问器。数组解构使用了数组的迭代器来遍历数组，并使用属性访问器来获取数组元素的值。对象解构使用了对象的属性访问器来获取属性的值，并使用迭代器来遍历对象的属性。

for...of 循环和 Iterator 接口：

在 ES6 中，引入了 for...of 循环，它可以用于遍历可迭代对象（Iterable）。可迭代对象是一种具有迭代器接口的对象，它可以用于使用 for...of 循环进行遍历。

迭代器接口是一种约定，用于定义可迭代对象的迭代器对象。迭代器对象需要包含一个 next() 方法，该方法用于返回下一个值，并标记迭代的结束。

为了实现迭代器接口，可以实现自定义的迭代器，用于遍历自定义对象的属性。通过定义自定义对象的迭代器对象，并在对象上实现 [Symbol.iterator] 方法，可以让该对象变为可迭代对象。然后，就可以使用 for...of 循环遍历该对象的属性。

例如，可以定义一个自定义对象，表示一个人的信息：

```javascript
const person = {
  name: 'Alice',
  age: 30,
  gender: 'female',
  [Symbol.iterator]: function* () {
    for (const key of Object.keys(this)) {
      yield [key, this[key]];
    }
  }
};

for (const [key, value] of person) {
  console.log(`${key}: ${value}`);
}
```

在上面的例子中，定义了一个自定义对象 person，并在该对象上实现了迭代器接口。该迭代器对象使用 for...of 循环遍历对象的属性，并使用 yield 语句返回属性的键值对。然后，在 for...of 循环中使用解构语法来获取键值对的值，并打印出来。

通过自定义对象的迭代器接口，可以实现更灵活、更高效的遍历方式，增强代码的可读性和可维护性。

## Class 用法 super原理 继承 如何定义私有属性

Class 是 ECMAScript 6 中引入的一种新的语言特性，用于定义类和对象。

Class 的使用方法类似于其他面向对象编程语言中的类。可以使用 class 关键字来定义一个类，使用 constructor 方法来定义类的构造函数，使用 this 关键字来定义类的属性和方法。

例如，下面的代码定义了一个名为 Person 的类：

```
javascriptCopy codeclass Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  sayHello() {
    console.log(`Hello, my name is ${this.name}, I'm ${this.age} years old.`);
  }
}
```

在上面的代码中，使用 class 关键字定义了一个名为 Person 的类，并使用 constructor 方法定义了该类的构造函数。构造函数接受两个参数 name 和 age，并将其保存到对象的 name 和 age 属性中。同时，定义了一个名为 sayHello 的方法，用于打印出对象的信息。

Class 还支持继承和 super 关键字。通过继承，可以创建一个新的类，并继承原有类的属性和方法。而 super 关键字可以用于在子类中调用父类的属性和方法。

例如，下面的代码定义了一个 Student 类，继承自 Person 类：

```javascript
class Student extends Person {
  constructor(name, age, grade) {
    super(name, age);
    this.grade = grade;
  }

  sayHello() {
    console.log(`Hello, my name is ${this.name}, I'm ${this.age} years old, and I'm in grade ${this.grade}.`);
  }
}
```

在上面的代码中，使用 extends 关键字创建了一个 Student 类，继承自 Person 类。在 Student 类的 constructor 方法中，使用 super 关键字调用了父类的 constructor 方法，并传入了 name 和 age 参数。同时，定义了一个名为 sayHello 的方法，用于打印出对象的信息和年级。

Class 中的私有属性和方法可以通过在属性和方法名前面添加 # 符号来定义。例如，下面的代码定义了一个私有属性：

```javascript
class MyClass {
  #privateField;

  constructor() {
    this.#privateField = 42;
  }

  getPrivateField() {
    return this.#privateField;
  }
}
```

在上面的代码中，使用 # 符号定义了一个私有属性 privateField，并在构造函数中将其初始化为 42。同时，定义了一个名为 getPrivateField 的方法，用于返回私有属性的值。注意，私有属性和方法只能在类的内部使用，无法在外部访问。

## AMD CMD UMD CJS ESM IIFE 的区别

AMD、CMD、UMD、CJS、ESM 和 IIFE 都是 JavaScript 中常见的模块化规范或模式，用于实现代码的模块化管理和组织。

- AMD（Asynchronous Module Definition）是一个异步模块定义规范，适用于浏览器端。AMD 使用 define() 函数来定义模块，并使用 require() 函数来引入模块。
- CMD（Common Module Definition）是另一个异步模块定义规范，适用于浏览器端和 Node.js 等环境。CMD 与 AMD 的不同之处在于，CMD 的模块加载是延迟执行的，只有在真正需要使用模块时才会加载。CMD 使用 define() 函数来定义模块，并使用 require() 函数来引入模块。
- UMD（Universal Module Definition）是一种通用的模块定义规范，既可以适用于浏览器端，也可以适用于 Node.js 等环境。UMD 可以识别 CommonJS、AMD 和全局变量（即 IIFE）等多种模块化规范，可以根据当前环境来选择合适的模块化方式。
- CommonJS（CJS）是一种同步模块定义规范，适用于服务器端。CJS 使用 require() 函数来引入模块，并使用 module.exports 和 exports 来导出模块。
- ES Modules（ESM）是 ECMAScript 6 中引入的一种模块化规范，适用于浏览器端和 Node.js 等环境。ESM 使用 import 和 export 关键字来定义和导入模块。
- IIFE（Immediately Invoked Function Expression）是一种立即执行的函数表达式，通常用于实现模块化和封装。

总之，这些模块化规范和模式都可以帮助我们更好地管理和组织 JavaScript 代码，并提高代码的可重用性、可维护性和可扩展性。不同的模块化规范和模式适用于不同的应用场景，开发者应该根据实际情况选择合适的模块化方式。

## Promise 静态方法 以及 all 实现原理 有限状态机

Promise 是 ES6 中引入的一种异步编程解决方案，可以用来处理异步操作和编写更加优雅的代码。Promise 有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败），一旦状态改变，就不会再变。

Promise 提供了一些静态方法来方便我们使用：

- Promise.resolve(value)：返回一个状态为已成功并携带指定值的 Promise 对象。
- Promise.reject(reason)：返回一个状态为已失败并携带指定错误原因的 Promise 对象。
- Promise.all(iterable)：返回一个 Promise 对象，该对象在所有 Promise 对象都已成功完成时被解析，其结果是一个包含所有 Promise 对象结果的数组，顺序与 Promise 对象在 iterable 中出现的顺序相同。
- Promise.race(iterable)：返回一个 Promise 对象，该对象在 iterable 中的任何一个 Promise 对象已成功完成时被解析，其结果是该 Promise 对象的结果。

Promise.all() 方法的实现原理是基于有限状态机（Finite State Machine）的概念。有限状态机是一种抽象的计算模型，它可以根据输入信号的变化来切换状态，并执行相应的操作。在 Promise.all() 中，有限状态机分为两个状态：

- pending：所有的 Promise 对象都处于 pending 状态时，Promise.all() 返回的 Promise 对象也处于 pending 状态。
- fulfilled：只要有一个 Promise 对象处于 rejected 状态，Promise.all() 返回的 Promise 对象就立即进入 rejected 状态；否则，所有的 Promise 对象都处于 fulfilled 状态时，Promise.all() 返回的 Promise 对象就进入 fulfilled 状态，并将所有 Promise 对象的结果存储在一个数组中，按照 Promise 对象在 iterable 中出现的顺序排列。

在实现过程中，我们可以使用一个计数器来记录所有 Promise 对象的状态，当所有 Promise 对象都完成时，就可以按顺序将它们的结果存储在一个数组中，并将 Promise 对象的状态设置为 fulfilled。如果有任何一个 Promise 对象处于 rejected 状态，就可以直接将 Promise 对象的状态设置为 rejected。

有限状态机是一种非常常见的计算模型，可以用于解决各种计算问题，包括异步编程中的状态管理。掌握有限状态机的原理和使用方法，对于理解 Promise 和其他异步编程解决方案都非常有帮助。

## map set weakMap weakSet

这四种数据结构都是 ES6 中新增的，它们都用于存储数据，并且具有一些独特的特性：

1. Map：Map 是一种键值对的数据结构，类似于对象，但可以使用任何类型的数据作为键名，可以快速地查找、删除和更新键值对，还可以通过 Map.prototype.forEach() 方法遍历所有的键值对。与对象不同的是，Map 对象中的键值对是按照插入顺序排列的，而不是按照属性名的字典顺序排列的。另外，Map 对象中的键名不会转换为字符串类型。
2. Set：Set 是一种无重复元素的数据结构，类似于数组，但可以存储任何类型的数据，并且不允许重复值存在。Set 对象具有一些常见的集合操作，例如并集、交集和差集，还可以通过 Set.prototype.forEach() 方法遍历所有的元素。与数组不同的是，Set 对象中的元素是按照插入顺序排列的，而不是按照索引顺序排列的。
3. WeakMap：WeakMap 是一种键值对的数据结构，类似于 Map，但只能使用对象作为键名，键名所指向的对象可以被垃圾回收，从而自动删除对应的键值对。WeakMap 对象具有一些常见的 Map 方法，例如 get()、set() 和 delete()，但没有 forEach() 方法。另外，WeakMap 对象中的键名只是对象的引用，而不是对象本身。
4. WeakSet：WeakSet 是一种无重复元素的数据结构，类似于 Set，但只能存储对象，并且对象的引用可以被垃圾回收，从而自动删除对应的元素。WeakSet 对象具有一些常见的 Set 方法，例如 add()、has() 和 delete()，但没有 forEach() 方法。

总的来说，这四种数据结构都是非常有用的，可以帮助开发者更加高效地存储和操作数据。在选择数据结构时，需要根据具体的场景和需求来选择适当的数据结构，以达到最好的性能和可维护性。

## 微任务 宏任务 同步 异步 async await

微任务和宏任务是 JavaScript 中的两种任务队列。宏任务是由浏览器或 Node.js 环境自行发起的任务，如 setTimeout、setInterval、setImmediate 和 I/O 等异步操作。微任务是由 JavaScript 引擎自行发起的任务，如 Promise 和 MutationObserver。

同步任务是指按照代码编写的顺序依次执行的任务，每个任务必须等待上一个任务完成后才能执行。异步任务是指不按照代码编写的顺序执行的任务，通常是由回调函数触发的，可以在上一个任务未完成时开始执行。

async 和 await 是 ES2017 中新增的异步编程方式，使得异步代码的写法更加简洁易懂。async 函数会自动将函数的返回值包装成一个 Promise 对象，并且 await 关键字可以将异步操作的结果转换为同步的代码风格。在 async 函数中，异步操作通常使用 Promise 对象来完成。

async 和 await 通常与 Promise 配合使用，await 可以等待 Promise 对象的状态变更，如果 Promise 对象变为 resolved 状态，则 await 表达式的值为 Promise 对象的 resolved 值，如果 Promise 对象变为 rejected 状态，则会抛出异常。

总的来说，微任务和宏任务是 JavaScript 中异步编程的重要概念，异步任务可以提高程序的性能和可维护性，async 和 await 则是更加简洁易懂的异步编程方式，使得异步代码的编写更加容易。

## 装饰器 以及 装饰器解决了什么问题

装饰器是一种元编程语法，可以动态地修改类或对象的行为。它是 ES2017 中新增的语法特性，目前已被广泛应用于 JavaScript 框架和库的开发中。

装饰器的基本语法如下：

```js
@decorator
class MyClass {}
```

其中，`@decorator` 表示装饰器，可以是一个函数或一个类，它将被应用于 `MyClass` 类，并修改其行为。装饰器可以在类的定义前使用，也可以在类的定义后使用。

装饰器可以用于修改类的行为，例如给类添加属性或方法，修改类的构造函数，添加注释等。它还可以用于修改方法的行为，例如为方法添加参数校验、日志输出等功能。装饰器可以嵌套使用，也可以链式调用，从而实现更加复杂的功能。

装饰器解决了一些代码复杂度和可维护性的问题。在传统的 JavaScript 中，常常需要使用大量的回调函数和条件语句来实现类似的功能，这样会导致代码的可读性和可维护性变得很差。使用装饰器可以将一些常见的功能封装成一个函数或一个类，从而减少重复的代码和逻辑，提高代码的可读性和可维护性。

总的来说，装饰器是一种非常有用的元编程语法，可以动态地修改类或对象的行为，从而实现更加简洁、易读、易维护的代码。它在 JavaScript 框架和库的开发中得到了广泛的应用，是一种非常有前途的编程技术。

## ArrayBuffer 如何使用 以及跟webGl 的关系

ArrayBuffer 是一种二进制数据缓冲区，可以用于存储和操作二进制数据。它提供了一种将二进制数据存储在内存中的机制，可以通过 TypedArray 或 DataView 对其进行操作。

使用 ArrayBuffer，可以在 JavaScript 中创建一块内存区域，这个内存区域可以是任何类型的二进制数据，例如图片、音频、视频、WebGL 中的顶点数据等等。在创建 ArrayBuffer 时，可以指定缓冲区的长度，以字节为单位。

TypedArray 是一种对 ArrayBuffer 进行封装的类型数组，可以将 ArrayBuffer 分成一段段的内存区域，并按照特定的数据类型进行操作。例如，可以使用 Int8Array 对 ArrayBuffer 进行操作，将缓冲区的内容按照 8 位有符号整数的格式进行读写。

DataView 是另一种对 ArrayBuffer 进行封装的类型数组，它提供了更加灵活的读写方式，可以读取和写入任何类型和大小的数据。例如，可以使用 DataView 对一个 Uint8Array 缓冲区进行操作，读取其中的一个 32 位无符号整数。

WebGL 是一种基于 OpenGL 的 3D 图形渲染技术，可以在浏览器中实现高性能的 3D 图形渲染。它使用了大量的二进制数据，例如顶点数据、纹理数据、着色器代码等等。因此，WebGL 通常需要使用 ArrayBuffer 和 TypedArray 进行数据的存储和操作。

总的来说，ArrayBuffer 是一种非常重要的二进制数据缓冲区，可以用于存储和操作任意类型的二进制数据。它与 TypedArray 和 DataView 一起，为 JavaScript 提供了一种方便、高效的二进制数据处理机制。在 Web 开发中，ArrayBuffer 通常与 WebGL 等技术一起使用，为浏览器提供高性能的 3D 图形渲染能力。

## 讲一下 GLSL Shader 实现亮度(Brightness)、对比度(Contrast) 和边缘检测(Edge Detection) 是如何实现的

GLSL 是一种用于编写着色器程序的语言，可以用于在 OpenGL 或 WebGL 中实现各种图形效果。下面介绍一下如何使用 GLSL 实现亮度、对比度和边缘检测效果。

亮度调整（Brightness）

亮度调整的实现相对简单，可以使用以下的着色器代码：

```javascript
varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float uBrightness;

void main() {
  vec4 color = texture2D(uSampler, vTextureCoord);
  color.rgb += uBrightness;
  gl_FragColor = color;
}
```

这段代码中，uSampler 是输入的纹理，vTextureCoord 是纹理坐标，uBrightness 是亮度值。首先使用 texture2D 函数从纹理中取出当前像素的颜色值，然后将其 RGB 值加上亮度值 uBrightness，最后输出 gl_FragColor。

对比度调整（Contrast）

对比度调整可以使用以下的着色器代码：

```javascript
varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float uContrast;

void main() {
  vec4 color = texture2D(uSampler, vTextureCoord);
  color.rgb -= 0.5;
  color.rgb *= uContrast;
  color.rgb += 0.5;
  gl_FragColor = color;
}
```

这段代码中，uSampler 是输入的纹理，vTextureCoord 是纹理坐标，uContrast 是对比度值。首先使用 texture2D 函数从纹理中取出当前像素的颜色值，然后将其 RGB 值减去 0.5，这样将其范围从 0-1 转换为 -0.5-0.5，接着将其乘上对比度值 uContrast，最后再加上 0.5，将其范围转换回 0-1。最终输出 gl_FragColor。

边缘检测（Edge Detection）

边缘检测可以使用以下的着色器代码：

```javascript
varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform vec2 uResolution;
uniform float uEdgeThreshold;

void main() {
  vec4 color = texture2D(uSampler, vTextureCoord);
  vec2 texel = vec2(1.0) / uResolution;
  vec4 colorTopLeft = texture2D(uSampler, vTextureCoord + vec2(-texel.x, -texel.y));
  vec4 colorTopRight = texture2D(uSampler, vTextureCoord + vec2(texel.x, -texel.y));
  vec4 colorBottomLeft = texture2D(uSampler, vTextureCoord + vec2(-texel.x, texel.y));
  vec4 colorBottomRight = texture2D(uSampler, vTextureCoord + vec2(texel.x, texel.y));
  float edgeValue = abs(-colorTopLeft.r - colorTopRight.r - colorBottomLeft.r - colorBottomRight.r + 4.0 * color.r);
  if (edgeValue > uEdgeThreshold) {
    gl_FragColor = vec4(1.0, 1.0, 1.0,} else {
    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
  }
}
```

这段代码中，uSampler 是输入的纹理，vTextureCoord 是纹理坐标，uResolution 是纹理分辨率，uEdgeThreshold 是边缘阈值。首先使用 texture2D 函数从纹理中取出当前像素的颜色值，然后根据像素的四个角的颜色计算出边缘强度，这里使用的是简单的 Sobel 算法。如果边缘强度大于阈值 uEdgeThreshold，那么输出白色（1.0, 1.0, 1.0, 1.0），否则输出黑色（0.0, 0.0, 0.0, 1.0）。

需要注意的是，GLSL 着色器语言是面向图形编程的，通常需要在 OpenGL 或 WebGL 中使用才能得到效果。而且以上的示例代码只是简单的演示，实际的图形效果可能需要更复杂的算法和技巧来实现。

## 计算机图形绘制原理

计算机图形绘制原理是指计算机如何使用图形学算法和图形硬件设备来绘制 2D 或 3D 图形的过程。通常包括以下几个步骤：

1. 几何处理：计算机需要根据输入的几何形状（如点、线、多边形等）来生成图形模型，通常需要进行变换、剪裁、投影等操作。
2. 光栅化：将几何模型转换为像素点，生成颜色和深度等信息。这个过程通常涉及到插值、抗锯齿等技术，以保证绘制出的图形质量。
3. 深度测试和透明度处理：处理图形的前后关系，通常需要根据像素的深度信息来决定绘制的顺序，并进行混合处理，以达到透明效果。
4. 显示输出：将图像输出到屏幕或其他设备上，通常需要进行颜色空间转换、颜色映射、伽马校正等操作。

这些步骤通常需要通过图形学算法和硬件设备共同完成。在现代计算机中，图形处理器（GPU）通常负责加速计算机图形绘制的过程，通过使用并行计算等技术，可以大幅提高计算机图形绘制的速度和质量。

需要注意的是，计算机图形绘制原理是一个非常复杂的领域，涉及到众多算法和技术，而且不同的图形应用场景和硬件设备可能需要不同的绘制方法。因此，对于从事计算机图形编程的开发者来说，需要掌握一定的图形学基础知识，以便能够设计和实现高效、精确、优美的图形应用。

## WebAssembly 工作原理 如何编译成wasm

WebAssembly（缩写为 wasm）是一种低级字节码，可以在现代 Web 浏览器中运行，提供了一种高效、跨平台的运行环境，使得开发者可以使用非 JavaScript 语言（如 C/C++、Rust 等）来开发 Web 应用程序。

WebAssembly 工作原理是这样的：开发者可以使用 C/C++、Rust 等语言编写程序，并将其编译为 WebAssembly 格式的二进制代码。然后，Web 浏览器可以将这些二进制代码加载到内存中，并通过解释器或即时编译器（JIT）将其转换为机器码，以在浏览器中执行。由于 WebAssembly 提供了一种跨平台的字节码格式，因此可以在各种计算机架构和操作系统上运行，实现了真正的跨平台性能。

WebAssembly 的编译过程通常包括以下几个步骤：

1. 编写 C/C++、Rust 等语言的程序，并使用相应的编译器（如 Clang、GCC、Rustc 等）将其编译为 WebAssembly 格式的二进制代码。
2. 使用 JavaScript 或其他语言（如 Rust、Go 等）开发 Web 应用程序，并将编译好的 WebAssembly 二进制代码加载到内存中。
3. 使用 JavaScript 与 WebAssembly 之间的接口来实现交互，例如将 JavaScript 中的数据传递给 WebAssembly 程序进行计算，或者将 WebAssembly 程序的结果传递回 JavaScript 中进行处理。

需要注意的是，由于 WebAssembly 本身是一种低级字节码，因此直接编写和调试 WebAssembly 程序相对比较困难，一般需要使用高级语言编写程序，并通过编译器将其转换为 WebAssembly 二进制代码。此外，WebAssembly 与 JavaScript 之间的交互也需要一定的编程经验和技巧。

## webRTC 架构 如何 实现推流 拉流

WebRTC 是一种基于 Web 技术实现的实时通信协议，它能够实现在浏览器中直接进行音视频通话或数据传输。下面分别介绍 WebRTC 推流和拉流的实现方式：

WebRTC 推流：

WebRTC 的推流方式主要涉及到媒体捕获、媒体处理和媒体传输三个方面。推流的主要流程如下：

1. 获取本地媒体流：使用 getUserMedia() API 获取用户的音视频流。
2. 处理媒体流：通过 MediaStream API 对音视频流进行处理，例如添加滤镜、旋转等。
3. 连接媒体服务器：使用 RTCPeerConnection API 建立与媒体服务器的连接，将媒体流传输到服务器。
4. 将媒体流发送到其他用户：通过 RTCDataChannel API 实现 P2P 通信，将媒体流发送给其他用户。

WebRTC 拉流：

WebRTC 的拉流方式主要涉及到信令服务器和媒体服务器两个方面。拉流的主要流程如下：

1. 与信令服务器建立连接：使用 WebSocket 或 HTTP 等协议与信令服务器建立连接，交换 SDP（Session Description Protocol）协议和 ICE（Interactive Connectivity Establishment）协议。
2. 建立与媒体服务器的连接：使用 RTCPeerConnection API 建立与媒体服务器的连接，开始进行媒体流的传输。
3. 接收媒体流：使用 MediaStream API 接收媒体流并进行处理，例如播放、截图等。

需要注意的是，WebRTC 推流和拉流的具体实现涉及到很多技术细节和底层协议，需要有一定的前端和后端开发经验。同时，WebRTC 也需要与媒体服务器、信令服务器等进行配合，才能够实现完整的音视频通信功能。

## 垃圾回收 内存泄漏 堆栈

垃圾回收是指在计算机程序中，自动管理不再使用的内存的一种技术。在 JavaScript 中，垃圾回收是由 JavaScript 引擎（如 V8 引擎）自动进行的，它会自动检测内存中不再使用的对象，然后释放这些对象占用的内存空间，以便程序可以继续使用这些空间。

内存泄漏是指程序在使用内存时，由于某些原因（如代码错误、不良的内存管理等）导致一些内存无法被垃圾回收机制回收，从而占用过多的内存空间，导致程序运行变慢、崩溃等问题。

堆和栈是内存分配的两种方式。栈内存主要用于存储函数的执行上下文、局部变量等，栈内存的大小是固定的，由系统自动分配和回收；堆内存主要用于存储动态分配的对象和数据，堆内存的大小不是固定的，需要手动分配和释放。在 JavaScript 中，原始类型的值存储在栈内存中，而对象和函数存储在堆内存中。

JavaScript 中的内存管理是基于垃圾回收机制的。在 JavaScript 中，垃圾回收机制会自动回收不再使用的对象，但需要注意的是，由于闭包、事件监听器、循环引用等原因，有时候一些对象可能不会被垃圾回收机制自动回收，从而导致内存泄漏。因此，编写 JavaScript 代码时，需要注意避免出现内存泄漏的情况，例如手动释放不再使用的对象、及时取消事件监听器等。

总之，了解垃圾回收、内存泄漏、堆栈等相关知识对于写出高效、稳定的 JavaScript 程序非常重要。

## 深拷贝 防抖 节流

深拷贝指的是在复制一个对象时，不仅复制对象的值和属性，而且还要复制对象的子对象（如果有的话）。浅拷贝只是复制了对象的值和属性，而没有复制子对象。JavaScript 中的深拷贝可以通过递归遍历对象的所有属性来实现。常见的深拷贝方法包括 JSON.parse(JSON.stringify(obj))、lodash 的 cloneDeep() 等。

防抖和节流都是用于控制函数执行频率的技术。防抖是指在触发事件后，等待一段时间（例如 500ms），如果这段时间内没有再次触发事件，那么就执行函数，否则就重新计时。常见的防抖函数包括：

```javascript
function debounce(func, delay) {
  let timer;
  return function() {
    const context = this;
    const args = arguments;
    clearTimeout(timer);
    timer = setTimeout(function() {
      func.apply(context, args);
    }, delay);
  };
}
```

节流是指在一段时间内（例如 500ms），最多执行一次函数。如果在这段时间内再次触发事件，那么就忽略这次触发。常见的节流函数包括：

```javascript
function throttle(func, delay) {
  let timer;
  return function() {
    const context = this;
    const args = arguments;
    if (!timer) {
      timer = setTimeout(function() {
        func.apply(context, args);
        timer = null;
      }, delay);
    }
  };
}
```

防抖和节流常用于优化性能、避免过度消耗资源的场景，例如监听滚动事件、输入框输入事件等。需要根据具体的场景选择使用防抖还是节流。

## 实现深拷贝的几种方法

实现深拷贝的几种方法包括：

1. 递归遍历对象：通过遍历对象的每一个属性，对于每一个属性值是对象的情况，继续递归遍历。这种方法可以处理对象中的任意层级关系，但是在处理循环引用的情况下会陷入死循环。

```javascript
function deepCopy(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  const result = Array.isArray(obj) ? [] : {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      result[key] = deepCopy(obj[key]);
    }
  }
  return result;
}
```

1. 利用 JSON 序列化：将对象序列化为字符串，再将字符串反序列化为对象，这样就可以获得一个新的对象，从而实现深拷贝。但是该方法不能处理函数、正则表达式等特殊类型的数据，并且会忽略对象中的 undefined 属性。

```javascript
function deepCopy(obj) {
  return JSON.parse(JSON.stringify(obj));
}
```

1. 使用第三方库：如 Lodash 的 `cloneDeep()` 方法，可以处理对象中的任意层级关系，还可以处理循环引用的情况，而且可以处理函数、正则表达式等特殊类型的数据。

```javascript
const _ = require("lodash");
const obj = { a: 1, b: { c: 2 } };
const newObj = _.cloneDeep(obj);
```

需要根据具体的情况选择合适的深拷贝方法。

- **追问 对象群嵌套15层 我想用14层的一个属性** 

最优解决方案 引出 Immutable js 追问 Immutable js 实现原理 字典 位分区 及 树压缩算法

## 什么是纯函数 什么是副作用函数

在编程中，一个函数被称为纯函数，当且仅当它的输出只取决于输入参数，而且没有副作用（side effect）。纯函数不会修改传递给它的任何参数或全局变量，也不会产生对外部世界的任何影响，其唯一的结果就是它的返回值。

纯函数的主要优点包括：

- 可重用性：纯函数的结果只取决于输入参数，因此可以在任何时候调用，并且不需要担心函数的上下文环境或全局状态。
- 可测试性：由于纯函数的输出只取决于输入参数，因此可以更轻松地编写测试用例来验证其正确性。
- 易于推理：由于纯函数不会产生副作用，因此可以更容易地理解代码，并推断出其执行过程和结果。

相反，副作用函数是会对外部世界产生影响的函数，它们可能会修改传递给它们的参数或全局变量，或者会对文件、网络、数据库等外部资源进行操作，这些都是对外部世界的副作用。副作用函数的主要问题是难以测试和推理，因为它们的输出结果可能不仅仅取决于输入参数，还取决于外部世界的状态。

因此，在编写代码时，尽可能地使用纯函数，以避免不必要的副作用，并提高代码的可重用性、可测试性和可维护性。如果必须使用副作用函数，则应该尽可能地限制它们的使用，并对它们的输入和输出进行准确的文档化和测试。

## 浏览器输入一个url 发生了什么

当在浏览器中输入一个 URL 后，浏览器会执行以下步骤：

1. 解析 URL：浏览器会解析输入的 URL，提取出协议、主机名、端口号、路径等信息。
2. 建立连接：浏览器会根据解析出的主机名和端口号建立一个到服务器的 TCP 连接。如果使用 HTTPS 协议，则还需要进行 SSL/TLS 握手过程建立安全连接。
3. 发送请求：浏览器会向服务器发送一个 HTTP 请求，其中包括请求方法（GET、POST 等）、请求头、请求体等信息。
4. 接收响应：服务器接收到请求后，会根据请求信息生成一个 HTTP 响应，其中包括响应状态码、响应头、响应体等信息，并通过 TCP 连接发送回浏览器。
5. 渲染页面：浏览器接收到响应后，会根据响应内容渲染出页面，并加载页面所需的所有资源（如 CSS、JavaScript、图片等），然后呈现给用户。
6. 断开连接：浏览器完成页面渲染后，会断开与服务器的 TCP 连接。

需要注意的是，上述步骤仅是一个简单的流程，实际情况中还可能会包括缓存机制、重定向、Cookie 处理、安全检查等其他步骤。

- **追问OSI 七层网络模型 三次握手 http https 区别 http1 2 3 区别 强缓存 协商缓存**

层。每一层都有不同的作用，可以通过它们之间的协议进行通信和数据传输。

三次握手是建立 TCP 连接的过程，分为以下三个步骤：

1. 客户端向服务器发送一个 SYN 报文，请求建立连接。
2. 服务器接收到 SYN 报文后，向客户端发送一个 SYN-ACK 报文，表示同意建立连接。
3. 客户端接收到 SYN-ACK 报文后，向服务器发送一个 ACK 报文，表示确认建立连接。

HTTP 和 HTTPS 都是应用层协议，用于客户端和服务器之间的数据传输。HTTP 是基于 TCP 协议的，而 HTTPS 则在 HTTP 的基础上增加了 SSL/TLS 加密层，提供更高的安全性。

HTTP/1.x 是一种基于文本的协议，每次请求都需要重新建立 TCP 连接，导致性能不佳。HTTP/2 则采用二进制格式，支持多路复用，可以在单个连接上同时进行多个请求，提高了性能。HTTP/3 则采用 QUIC 协议，通过将 TCP 和 HTTP 合并为一个协议，进一步提升了性能和安全性。

强缓存和协商缓存都是浏览器缓存机制的一种。强缓存是指浏览器直接从缓存中获取资源，不向服务器发送请求，可以通过设置 HTTP 响应头中的 Cache-Control 和 Expires 字段来实现。协商缓存是指浏览器向服务器发送请求，服务器会根据请求中的条件判断决定是否返回资源，可以通过设置 HTTP 响应头中的 Last-Modified 和 ETag 字段以及请求头中的 If-Modified-Since 和 If-None-Match 字段来实现。

Last-Modified 和 If-Modified-Since 用于判断资源是否过期，ETag 和 If-None-Match 则用于判断资源内容是否有变化。如果资源没有过期或内容没有变化，则服务器会返回 304 Not Modified 响应，浏览器会从缓存中获取资源，否则会重新请求资源。

## Ajax fetch navigator.sendBeacon 三个的区别

Ajax、fetch 和 navigator.sendBeacon 都是用于在客户端与服务器之间进行数据交互的技术，但它们之间有以下几个区别：

1. Ajax 是使用 XMLHttpRequest 对象发送异步请求，通过监听 XMLHttpRequest 对象的状态变化来处理响应，可以实现前后端数据交互。而 fetch 是基于 Promise 对象实现的，使用简单、易于使用，支持链式调用。
2. navigator.sendBeacon 是在页面关闭或卸载时，使用 HTTP POST 方法将数据异步发送到服务器，可以保证数据的可靠传输。相比之下，Ajax 和 fetch 都是在页面处于活动状态时才能发送请求。
3. Ajax 和 fetch 默认都不会将 Cookie 等认证信息发送到服务器，需要手动设置请求头。而 navigator.sendBeacon 可以在浏览器关闭或卸载时发送数据，不受浏览器跨域策略的限制。

总的来说，Ajax 和 fetch 更适合在页面活动状态下进行前后端数据交互，而 navigator.sendBeacon 则更适合在页面关闭或卸载时发送数据，以保证数据的完整性和可靠性。

## nodejs 是否用过

- **是否用过一些库 如 express koa nest** 

作为一名前端开发者，我使用过 Node.js，并且也使用过一些常用的 Node.js 库，如：

- Express：一个流行的 Web 应用程序框架，用于构建 Web 应用程序和 API。
- Koa：另一个流行的 Web 应用程序框架，相比于 Express 更轻量级，也更加灵活。
- Socket.io：一个实时通信库，可以在客户端和服务器之间建立 WebSocket 连接，实现实时通信。
- Nodemon：一个用于监视 Node.js 应用程序中文件更改并自动重启服务器的工具。
- Axios：一个基于 Promise 的 HTTP 客户端，用于发送 Ajax 请求和进行服务器通信。
- Lodash：一个实用工具库，提供了许多常用的 JavaScript 工具函数，可以用于简化开发工作。

除此之外，我也使用过一些 Node.js 的框架，如 Nest.js，它是一个基于 TypeScript 的 Web 应用程序框架，可以用于构建高度可扩展的服务器端应用程序。

- **追问用的什么数据库 以及高速缓存 如 redis ，用的什么ORM框架**

我在项目中使用过多种数据库和缓存技术，具体取决于项目需求和架构设计。以下是我在项目中使用过的一些技术：

- 数据库：MySQL、PostgreSQL、MongoDB、Redis、SQLite。
- 高速缓存：Redis、Memcached。
- ORM框架：Sequelize、TypeORM、Mongoose等。

对于关系型数据库，我使用 Sequelize 和 TypeORM 这两个 ORM 框架，它们提供了基于 Promise 的异步操作，能够很好地支持异步编程。对于非关系型数据库，我使用 Mongoose 来操作 MongoDB 数据库。同时，我也使用过 Redis 作为缓存，通过 Node.js 提供的 Redis 客户端库，可以方便地使用 Redis 的各种功能，如缓存数据、计数器、消息队列等。

- **如果熟悉express 追问 中间件原理**

Express 中间件是指在请求和响应之间进行处理的函数，可以通过 `app.use()` 方法将中间件添加到应用程序的处理流程中。

中间件的原理可以简单描述为：当客户端发起请求时，请求会首先经过路由处理，然后进入中间件处理流程。在中间件处理流程中，请求会依次经过添加的中间件函数，每个中间件函数可以对请求进行处理并将请求传递给下一个中间件，直到最后一个中间件处理完请求并返回响应。

中间件函数可以访问请求对象（`req`）、响应对象（`res`）和下一个中间件函数（`next`），可以在处理请求时进行一些特定的操作，如记录日志、验证用户身份、修改响应头等。

Express 中间件有两种类型：应用程序级别的中间件和路由级别的中间件。应用程序级别的中间件会在整个应用程序中都起作用，而路由级别的中间件仅作用于特定的路由或路由组中。

Express 中间件的执行流程是基于一个叫做“洋葱模型”的原理。在这个模型中，请求首先经过应用程序级别的中间件处理，然后进入路由级别的中间件处理，路由级别的中间件可能又包含了子级路由或其他中间件。处理请求的过程类似于在一个“洋葱”中依次穿过多个层次，直到处理完成并返回响应。

总之，Express 中间件是一个非常强大和灵活的功能，可以方便地进行请求处理和响应控制，提高应用程序的可维护性和可扩展性。

- **熟悉nest 追问 ioc控制反转 DI 依赖注入 设计模式 以及MVC 架构 和MVVM 区别**

Nest 是一个基于 Node.js 的 Web 框架，提供了一些有用的功能和特性，如模块化、依赖注入等。下面我分别回答追问：

- IoC 和 DI

IoC (Inversion of Control) 指的是控制反转，即将对象的创建、初始化、使用等控制权交给容器管理。而 DI (Dependency Injection) 则是 IoC 的一种具体实现，指的是通过容器将对象所依赖的其他对象注入到对象中，实现对象间的解耦。在 Nest 中，可以使用 @Injectable 装饰器来标识需要注入的对象，使用 @Inject 装饰器来注入其他对象。

- 设计模式

Nest 中应用了许多设计模式，如单例模式、观察者模式、装饰器模式等。其中，装饰器模式是 Nest 中最为常见的设计模式之一，用于实现依赖注入和元编程等功能。

- MVC 和 MVVM

MVC (Model-View-Controller) 和 MVVM (Model-View-ViewModel) 都是常见的前端架构模式。MVC 将应用程序分为三个部分：模型、视图和控制器，它们分别处理数据、用户界面和应用程序逻辑。而 MVVM 将应用程序分为三个部分：模型、视图和视图模型，它们分别处理数据、用户界面和视图逻辑。在 MVVM 中，视图模型充当了控制器的角色，将视图和模型分离开来。

在 Nest 中，常用的 MVC 架构可以通过将路由、控制器和服务等功能组件化实现。而 MVVM 架构则需要使用前端框架来实现，如 Angular 等。

- **继续追问nest rxjs 库用法 以及原理** 

在 Nest 中使用 RxJS，主要是使用 RxJS 的 Observable 类型和相关的操作符来实现异步编程。在 Nest 中，你可以使用 RxJS 的 Observable 对象作为异步请求的响应类型，同时使用操作符来进行流式处理和转换。

例如，可以使用 RxJS 的 from() 操作符将一个 Promise 对象转换为 Observable 对象：

```javascript
import { from } from 'rxjs';

async function fetchData(): Promise<any> {
  // ...
}

async function handler() {
  const data$ = from(fetchData());
  // ...
}
```

还可以使用 RxJS 的各种操作符来对 Observable 进行各种操作，例如 map()、filter()、reduce() 等。

在 Nest 中，还可以使用 RxJS 的 Subject 类型来实现观察者模式，让多个组件之间进行通信。

至于 RxJS 的实现原理，它主要是基于观察者模式和迭代器模式，通过 Subject 和 Observable 类型来实现异步事件流的处理和传递。RxJS 中的操作符主要是基于高阶函数和闭包来实现的，可以将多个操作符组合成一个操作链，以便对事件流进行各种复杂的操作和转换。同时，RxJS 还支持多种调度器，可以控制异步任务的执行时机和线程。

总之，RxJS 是一种非常强大的异步编程库，可以大大简化异步编程的复杂度，并提供了很多高级的操作符和调度器，可以让开发者更方便地处理异步事件流。在 Nest 中，可以灵活地使用 RxJS 来处理异步请求和事件，实现更加高效和优雅的代码。

- **继续追问nest 微服务 gRPC MQ 以及网关 。**

Nest.js 是一个基于 Node.js 平台的开发框架，可以用于构建高效且可扩展的服务器端应用程序。除了提供一些常用的模块和库，它还内置了一些重要的特性，如依赖注入、模块化、中间件、路由和过滤器等，使开发者可以更快速地构建可维护、可扩展的应用程序。

微服务是一种架构风格，用于构建单个应用程序的多个独立组件。每个组件都是一个独立的进程，可以单独部署和运行。微服务架构旨在提高应用程序的可扩展性和可维护性，因为每个组件可以独立开发、测试、部署和维护。

gRPC 是一种高性能、开源的远程过程调用（RPC）框架，基于 Protocol Buffers（protobuf）序列化协议。它可以在不同的语言和平台之间进行通信，并支持流式传输和双向流式传输。gRPC 旨在提高应用程序的性能和可扩展性。

MQ（Message Queue，消息队列）是一种用于在应用程序之间进行异步消息传递的技术。MQ 可以将消息存储在队列中，然后在需要的时候将其传递给目标应用程序。这种异步通信模式可以提高应用程序的可伸缩性和可靠性。

网关是一个用于转发和处理请求的中间层，通常用于处理来自多个微服务的请求。网关可以负责路由、负载均衡、安全性、协议转换等任务，从而简化了微服务架构中的客户端代码。常见的网关包括 Nginx、API Gateway 等。

在 Nest.js 中，可以使用一些库和模块来实现微服务、gRPC、MQ 和网关等功能。例如，可以使用 @nestjs/microservices 模块来构建微服务，使用 @nestjs/grpc 模块来实现 gRPC，使用 @nestjs/bull 模块来使用 Redis Bull 库实现 MQ，使用 @nestjs/graphql 模块来实现 GraphQL API 等。同时，Nest.js 还提供了一些内置的特性和工具，如拦截器、管道、异常过滤器等，以帮助开发者更快速地构建可靠的微服务应用程序。

## 聊聊数据库 mysql 底层数据结构 为什么使用B+ 树，继续追问 mysql事务 追问悲观锁和乐观锁

MySQL 是一种关系型数据库管理系统，其底层数据结构主要使用 B+ 树实现索引。

B+ 树相对于 B 树而言，具有更好的磁盘读写性能。因为 B+ 树内部节点不保存数据，只保存关键字，而数据都保存在叶子节点中，使得每次查询都要查找到叶子节点，从而减少了磁盘 I/O 次数。同时，由于数据都在叶子节点中，因此可以将叶子节点顺序存储在磁盘上，使得范围查询更加高效。

MySQL 的事务主要是通过 InnoDB 存储引擎来实现的，而 InnoDB 存储引擎支持基于多版本并发控制（MVCC）的事务处理机制。在 MVCC 机制中，每个事务在执行时都可以看到一个 snapshot 视图，也就是一个时间点数据库的快照。在修改数据时，会先将原始数据复制一份，然后在新版本中进行修改，以此来保证原始数据的一致性。

在 MySQL 中，悲观锁和乐观锁都是用来解决并发访问数据库的问题的。悲观锁指的是在整个事务过程中都持有锁，以防止其他事务的干扰，而乐观锁则是在读取数据时不加锁，而是在写入数据时检查数据版本，以避免并发写入冲突。具体来说，悲观锁是通过在事务中使用 SELECT FOR UPDATE 或者 SELECT ... LOCK IN SHARE MODE 语句来实现的，而乐观锁则是通过在表中添加版本号或时间戳等字段，并在更新时检查这些字段来实现的。

## 聊聊redis redis是单线程还是多线程 以及底层原理

Redis 是单线程的内存键值存储数据库，也被称为数据结构服务器，它支持多种类型的数据结构，例如字符串、哈希、列表、集合和有序集合。它的底层数据结构是基于内存的字典结构，通过哈希表来存储键值对数据。

虽然 Redis 是单线程的，但是它通过异步 I/O 和多路复用技术来实现高并发处理。Redis 的单线程模型避免了多线程并发时的竞争、死锁和线程切换等问题，同时也可以最大限度地利用 CPU 缓存，提高了系统的性能。

在 Redis 中，所有的操作都是原子性的，它支持多种事务模式，包括单条命令、多个命令的流水线操作和基于乐观锁的事务操作。Redis 的事务机制可以通过 MULTI、EXEC、WATCH、UNWATCH 等命令来实现，它允许一组命令以原子性的方式执行，这样就可以确保数据的完整性和一致性。

悲观锁和乐观锁是数据库并发控制的两种基本思想。悲观锁认为在并发环境下，数据很有可能被其他事务修改，因此在操作数据时需要进行加锁，以避免数据的冲突和不一致。乐观锁则认为在大多数情况下，数据的冲突是较少的，因此不需要进行加锁，而是在操作数据时通过版本号等机制来检查数据的一致性，以避免数据冲突。

在 Redis 中，由于其单线程模型的限制，无法使用传统的悲观锁机制，因此 Redis 通常采用基于乐观锁的并发控制方式，例如在事务操作中使用 WATCH 命令监控一个或多个键值，并在 EXEC 命令执行前检查键值是否被修改，以保证数据的一致性。此外，Redis 还提供了其他的一些并发控制机制，例如 SETNX、GETSET 等命令来实现基于 CAS（Compare and Swap）的操作。

## 聊聊nodejs 的 vm虚拟机 以及PAI 以及 底层libuv openSSL

Node.js 中的 VM 模块提供了一个可编程的沙盒环境，允许在 Node.js 运行时中运行 JavaScript 代码。它提供了一种安全的方式，允许您动态编译和执行代码，同时保持主应用程序的隔离。在 VM 中运行的代码被隔离在一个虚拟机中，不能访问主程序的变量、函数或对象，因此可以防止未经授权的代码执行对主程序的影响。

Node.js 的核心 API 提供了许多用于构建服务器端应用程序的模块。其中最重要的是 HTTP 模块，它允许您创建 Web 服务器和客户端。Node.js 还提供了许多其他模块，包括用于文件 I/O、网络编程、进程管理、加密等的模块。

Node.js 的底层使用了 libuv 库，它提供了跨平台的异步 I/O、定时器和线程池等功能，是 Node.js 能够实现非阻塞 I/O 的基础。另外，Node.js 还使用了 OpenSSL 库来提供加密和解密功能。

Node.js 的 API 提供了许多用于构建 Web 应用程序的模块，包括 Express、Koa、Hapi 等。这些框架提供了简单的路由、中间件等功能，使得 Web 应用程序的开发更加高效。

与 Web 应用程序相关的一个重要概念是 API，它是一组定义如何与 Web 应用程序交互的接口。Node.js 的 API 可以通过各种方式暴露，包括 RESTful API、GraphQL API 等。在构建 Web 应用程序时，您可以使用这些 API 来提供数据服务、身份验证、授权等功能。

总之，Node.js 是一种非常强大的 JavaScript 运行时，可用于构建服务器端应用程序、Web 应用程序和命令行工具等。它提供了一个非阻塞 I/O 模型，使得能够处理大量的并发请求，同时还具有高效的网络编程、强大的 API 和库支持等优点。

## 聊聊nodejs 子线程 进程守卫怎么做

在 Node.js 中，可以使用子线程（child_process）来创建新的进程，执行一些耗时操作，防止阻塞主进程。常见的子线程创建方法有：

1. 使用 spawn 方法：在一个新的进程中执行一个命令。
2. 使用 exec 方法：在一个 shell 中执行一个命令。
3. 使用 execFile 方法：直接执行一个文件。
4. 使用 fork 方法：创建一个新的 Node.js 进程，可以在父进程和子进程之间发送消息。

对于进程守卫，通常需要监控一个进程的状态，当进程退出或者崩溃时，立即重启该进程，保证服务的可靠性。在 Node.js 中，可以使用一些第三方模块来实现进程守卫，如 PM2、forever 等。这些模块可以监控 Node.js 进程的状态，实现自动重启和负载均衡等功能。

其中，PM2 是最常用的 Node.js 进程管理器之一，可以通过 PM2 启动、停止和管理 Node.js 应用程序，并提供日志记录、负载均衡和故障恢复等功能。PM2 还支持在集群模式下启动多个 Node.js 进程，以实现负载均衡和高可用性。

关于 Node.js 底层的 libuv 和 OpenSSL，libuv 是 Node.js 的事件驱动 I/O 模型的核心，提供了事件循环、异步 I/O、进程间通信、定时器等功能。而 OpenSSL 则是一个开源的安全套接字层，提供了加密、解密、认证和密钥管理等功能，Node.js 通过 OpenSSL 实现了 HTTPS、TLS/SSL 等安全协议。

## 聊聊 断点续传怎么做（前后端）

断点续传是指在文件传输时，如果因为网络中断、断电等原因导致文件传输失败，可以从上次传输失败的地方继续传输，避免重新传输整个文件。

实现断点续传的方法有很多，下面简单介绍一下常用的前后端实现方式：

前端：

1. 使用 XMLHttpRequest 对象进行文件上传，监听 upload 事件的 progress 属性，获取当前上传进度并发送给后端，后端通过判断当前已上传的字节数来决定从哪个位置开始继续上传。
2. 使用 fetch API 进行文件上传，同样监听 progress 事件来获取上传进度，其实现方式与 XMLHttpRequest 类似。

后端：

1. 在后端使用 range 请求头，通过请求头中的 Range 属性来获取上次上传失败时已上传的字节数，然后从这个位置开始继续上传。
2. 将上传文件分成多个部分，每个部分都有一个唯一的标识符，上传时将这些部分分别上传并记录已上传的字节数，上传完成后将这些部分合并成一个完整的文件。

实现断点续传需要注意以下几点：

1. 文件上传时需要对文件进行分块处理，每个块大小合适，不能太小导致频繁的上传请求，也不能太大导致上传失败时需要重新上传较大的文件块。
2. 后端需要能够判断文件是否已经存在，如果存在则不需要重新上传。
3. 前端需要考虑上传进度的显示，可以通过进度条等方式来展示上传进度。

总之，实现断点续传需要前后端配合，合理地进行文件分块、断点记录、上传进度监控等处理。

## Npm 是什么 package-lock.json 是做什么的 npm 缓存原理

Npm（Node Package Manager）是 Node.js 的包管理工具，用于管理 Node.js 应用程序的依赖关系。

在一个 Node.js 项目中，通常使用 npm 来安装、更新和管理各种 JavaScript 包。npm 会自动下载和安装这些包及其所有依赖项，并将它们保存在项目的 node_modules 目录中。

package-lock.json 文件是 npm 在安装或更新包时自动生成的一个锁定文件，用于确保安装的包的版本和依赖关系是固定的。这个文件记录了每个包的精确版本号，以及该版本所依赖的其他包的版本号，以便在重复安装时确保相同的依赖关系。

npm 缓存原理是，在安装包时，npm 会将下载的包存储在本地缓存中，以便在后续安装相同版本的包时可以快速获取。缓存目录的位置默认为 `$HOME/.npm` 或 `$HOME/.npm-cache`。当需要重新安装包时，npm 会优先使用本地缓存中已经存在的包，而不是重新下载。

此外，npm 还支持私有包管理和发布、依赖树可视化、命令行脚本等功能，使得 JavaScript 包的管理更加简单和方便。

## pnpm 实现原理 以及 monorepo 架构

pnpm是一个npm的替代品，它能够提供更快、更节省磁盘空间的包管理体验，同时还支持monorepo架构，可以更好地管理多个项目之间共用的代码和依赖。是一个面向 monorepo 架构的 npm 包管理器，可以帮助开发者更好地管理多个项目间共享的依赖项。在 PNPM 中，依赖包是使用符号链接来共享的，这也是 PNPM 的主要区别于 npm 和 yarn 的地方

PNPM 通过在根目录下创建一个 `node_modules/.pnpm` 目录，将所有的依赖安装到这个目录中，然后在每个项目中创建一个 `node_modules` 的符号链接指向 `.pnpm` 目录，来共享依赖包。这样做可以节省磁盘空间，减少依赖包下载和安装的时间。

在 PNPM 中，软链接和硬链接的使用是由系统决定的，Linux 和 macOS 通常使用硬链接，而 Windows 上会使用软链接。硬链接可以将多个文件名指向同一份文件，但必须在同一个文件系统上，而软链接则可以跨文件系统使用。

PNPM 的软链接和硬链接的做法是基于系统平台的实现，这样可以让 PNPM 更好地在不同的系统上工作，同时还能够最大限度地减少磁盘占用和提高安装速度。

pnpm实现原理：

1. 每个包在磁盘上只有一份，所有项目共享这个包
2. 版本号和语义化版本控制
3. 包的依赖和子依赖以单独的模块安装在一个共同的存储位置，而不是在每个项目中重复安装
4. 模块符号链接到每个项目的node_modules目录，就像npm一样

monorepo架构是指将多个相关的项目组织在一个代码库中的架构。它可以减少代码的复制、管理多个代码库的复杂性，并可以共享代码和依赖项。pnpm支持monorepo架构，可以更好地管理多个项目之间共用的代码和依赖。可以通过pnpm的工作区特性，将多个项目的依赖关系放在同一个仓库下，提高代码的可维护性和管理效率。

## 如何发布 npm 包 有没有发过 自己的 npm包 周下载量多少

发布 NPM 包的流程一般如下：

1. 注册 NPM 账号
2. 初始化项目，创建 package.json 文件
3. 编写代码，添加入口文件
4. 在 package.json 文件中添加相关信息，如名称、版本、描述、作者等
5. 使用 npm publish 命令发布包

如果你想要发布自己的 NPM 包，可以按照上述流程进行操作。注意要遵循包命名规范，尽量使用独一无二的包名，避免命名冲突。同时，要遵循 NPM 社区的行为准则和最佳实践，避免出现不必要的问题。

我个人曾经发布过几个 NPM 包，其中下载量最多的一个是一个工具库，每周下载量大约在 500 左右。但是，下载量不应该是判断一个包质量和使用情况的唯一标准，重要的是包是否满足用户需求，代码是否健壮、易用、易维护等。

## webpack vite rollup esbuild

Webpack、Vite、Rollup 和 esbuild 都是前端项目构建工具，它们都可以实现代码的打包、编译、压缩等功能。它们各自的特点如下：

Webpack： Webpack 是目前最流行的前端构建工具之一，它可以将多个文件打包成一个文件，并且支持插件和加载器，可以处理各种不同的文件类型。Webpack 5 更是推出了 Module Federation 功能，可以支持多个项目之间共享代码，极大提高了前端项目的可维护性和可扩展性。

Vite： Vite 是一个基于 Rollup 和浏览器原生 ES 模块导入功能的新型前端构建工具。与传统的构建工具不同，Vite 采用了「即时编译」的方式来提高开发效率，它通过预构建原生 ES 模块并通过浏览器原生支持的 import-on-demand 方式引入模块，大大提高了开发效率。

Rollup： Rollup 是一个专门用来打包 JavaScript 库的构建工具，它可以将多个模块打包成一个文件，并且可以通过插件来进行优化。Rollup 的打包结果更加精简，适用于发布库和组件。

esbuild： esbuild 是一个基于 Go 语言编写的 JavaScript/TypeScript 编译器，它的编译速度非常快，且占用内存很少。esbuild 支持多种文件格式和多种构建选项，同时也支持 Tree shaking 和代码压缩等功能，可以帮助我们快速地构建高性能的前端应用。

总的来说，不同的工具适用于不同的场景，我们需要根据自己的需求来选择合适的工具。

## Webpack 脱口而出的配置 webpack 分包 webpack 打包优化 webpack打包原理 以及 HMR 原理

Webpack 是一个现代 JavaScript 应用程序的静态模块打包器，通过构建一个依赖关系图，可以将项目中所有的模块打包成一个或多个 bundle，以供浏览器使用。

一些常见的 Webpack 配置包括：

- entry：指定打包的入口文件。
- output：指定打包后的输出文件路径和文件名。
- module：配置模块加载器，比如babel-loader用于转译ES6及以上语法。
- plugins：增强 Webpack 功能的插件，比如html-webpack-plugin可以自动生成HTML文件，并将打包后的文件自动引入HTML文件。

Webpack 还提供了很多优化策略，如：

- Code Splitting：通过分割代码块，实现按需加载，减少首次加载时间。
- Tree Shaking：通过静态分析代码，去除没有被引用的代码，减少打包体积。
- HMR（Hot Module Replacement）：热替换模块，修改代码后无需刷新浏览器，可以直接看到修改后的效果。

Webpack 的打包原理是，通过从入口文件开始，递归分析入口文件和其依赖的模块，构建成一个依赖关系图，然后根据这个图进行代码分割、文件压缩等操作，最终输出打包后的文件。

HMR 的原理是通过在浏览器和服务器之间建立 WebSocket 连接，当文件发生变化时，服务器通知浏览器进行更新，使得开发者可以在不刷新浏览器的情况下实时看到修改后的效果。

关于打包优化，一些常用的手段包括：

- 按需加载：尽可能地将代码分割成小块，按需加载，减少首次加载时间。
- 缓存：使用 hash 值命名文件，根据文件内容是否变化，决定是否重新加载文件，减少加载时间。
- Tree Shaking：去除没有被引用的代码，减少打包体积。
- 长缓存：对于静态资源，可以配置 HTTP 缓存头，提高用户体验。
- 减少打包体积：去除冗余代码、使用 tree shaking、使用动态导入等方法。
- 加快打包速度：使用多线程打包、使用缓存等方法。
- 按需加载：使用 code splitting 和懒加载等方法，按需加载模块。
- 使用 CDN 加载：使用 CDN 加载静态资源，减少服务器负载，提高用户访问速度。

Webpack 打包原理：

Webpack 的打包过程是将所有的模块转换为一个个静态资源，然后根据依赖关系进行合并和压缩，最终生成一个或多个打包文件。Webpack 的工作原理主要有三个核心组件：Entry、Output 和 Loader。

1. Entry：指定入口文件，Webpack 从这里开始解析依赖关系，建立一个依赖图谱。
2. Loader：将非 JS 文件（如 CSS、图片等）转换为 JS 模块。
3. Output：指定输出文件名和路径，Webpack 根据依赖图谱生成打包文件。

HMR 原理：

HMR（Hot Module Replacement）是 Webpack 的热替换功能，可以在不刷新页面的情况下替换模块代码，提高开发效率。HMR 的实现原理主要是将更新的模块代码通过 Websocket 推送给浏览器，然后使用模块热替换技术替换当前模块的代码。在代码更新的过程中，HMR 会保留应用的状态，从而实现无感知的代码更新。

## Vite原理 中间件原理 是否写过vite插件

Vite 是一个现代化的前端构建工具，它的特点是快速的冷启动和快速的热更新。Vite 的原理是利用浏览器原生的 ES 模块导入功能，在开发阶段直接使用浏览器加载模块，无需打包构建，从而实现了快速的冷启动和热更新。

Vite 的工作流程可以简单概括为：

1. 当我们启动 Vite 后，Vite 会在浏览器中启动一个服务器，该服务器会拦截所有的静态资源请求。
2. 当浏览器请求一个 JavaScript 模块时，Vite 会分析该模块的依赖关系，然后将模块转换为浏览器可识别的格式。
3. 如果模块有更新，Vite 会自动更新模块，而不需要重新构建整个应用程序。

Vite 采用了中间件的方式实现了上述工作流程。中间件是一种可以处理请求和响应的函数，它可以接收一个请求，对请求进行处理，然后返回一个响应。Vite 使用了 Koa 框架来实现中间件功能。

在 Vite 中，一个请求会经过多个中间件，每个中间件负责不同的功能。例如，对于一个请求，Vite 的中间件可能会负责拦截请求、解析请求、编译代码、返回响应等。

Vite 的中间件机制为开发者提供了很大的灵活性和可扩展性。我们可以根据自己的需求编写自己的中间件，以实现一些特定的功能，例如添加全局变量、请求代理、自定义路由等。

我曾经开发过一个 Vite 插件，用于在 Vite 中集成 Ant Design 组件库。该插件会自动引入 Ant Design 的 CSS 样式文件和 JavaScript 模块，以便在应用程序中使用 Ant Design 组件。这个插件的主要实现原理是在 Vite 中添加一个中间件，用于拦截对 Ant Design 组件的引用，并将其转换为浏览器可识别的格式。

至于下载量，我还没有发布过自己的 npm 包，因此也没有下载量数据。

## rollup 和 webpack的区别

Rollup 和 webpack 都是前端项目打包工具，它们的主要区别在于：

1. 打包粒度：Rollup 更适合打包库和组件，可以将多个模块打包为一个文件，以实现更小的打包体积和更快的加载速度；而 webpack 更适合打包整个应用程序，可以将多个页面和组件打包在一起。
2. 调试能力：webpack 提供了更好的调试能力，可以在开发环境中方便地进行源代码调试和错误追踪；而 Rollup 的调试能力相对较弱。
3. 处理模块的方式：Rollup 默认采用 ES6 模块规范来处理模块依赖，支持 Tree-shaking 和按需加载，可以将多个模块打包成一个文件，减少重复代码和不必要的依赖；而 webpack 可以处理各种模块规范，如 CommonJS、AMD、ES6 等，但 Tree-shaking 功能不如 Rollup 强大。
4. 插件系统：Webpack 的插件系统非常丰富，可以通过插件实现各种自定义功能，例如代码压缩、图片压缩、打包分析等；而 Rollup 的插件系统相对简单，可扩展性不如 webpack。

总之，Rollup 更适合打包库和组件，可以实现更小的体积和更快的加载速度，而 webpack 更适合打包整个应用程序，提供了更丰富的插件和调试能力。

## esBuild 常用命令 以及 为什么这么快

esbuild 是一个快速、可扩展、易于使用的 JavaScript 构建工具，它支持转换和打包各种 JavaScript 文件格式。常用的命令包括：

- `esbuild script.js --bundle --outfile=out.js`：将 script.js 打包为一个文件 out.js。
- `esbuild script.js --minify --outfile=out.js`：将 script.js 打包并压缩，输出为 out.js。
- `esbuild script.js --watch --serve:8080`：监听文件变化，并在 [http://localhost:8080](http://localhost:8080/) 上启动一个 web 服务器。

esbuild 之所以如此快，是因为它使用了 Golang 编写，并利用了 Go 语言的并发优势，同时在设计上采用了一些优化策略。例如，它使用了先转换再打包的策略，减少了打包时的工作量；它还利用了多线程和缓存等技术，提高了构建效率。此外，esbuild 还支持插件，可以轻松地扩展其功能。

## Vue2 3 区别

Vue 2 和 Vue 3 之间存在以下区别：

1. 性能优化：Vue 3 采用了静态树提升（Static Tree Optimization）的技术，能够在渲染时跳过静态节点的比对和渲染，从而提升渲染性能。此外，Vue 3 还对响应式系统进行了优化，使用了 Proxy 替代 Object.defineProperty，提高了性能和功能。
2. Composition API：Vue 3 引入了 Composition API，使得组件的逻辑可以更加清晰地组织和复用，而不再需要依赖于 Options API。
3. 全局API的改动：Vue 3 中一些全局 API 发生了变化，例如：Vue.filter 改为了 app.component('filter', ...)，Vue.directive 改为了 app.directive(...)。
4. 自定义渲染器：Vue 3 允许开发者通过自定义渲染器来扩展 Vue 的能力，可以用来支持一些不同的渲染目标（例如，服务器端渲染）。
5. 源码结构的改变：Vue 3 源码结构进行了重构，使得其更加清晰易懂，也方便了开发者的贡献和维护。
6. TypeScript 支持：Vue 3 在设计上更加友好 TypeScript，并提供了更好的类型推断和支持。

需要注意的是，Vue 3 在一些 API 上与 Vue 2 不兼容，开发者需要进行相应的修改。

## Diff算法 追问 最长递增子序列算法 以及 二分查找 和 贪心算法

Diff算法是一种用于前端框架中数据更新优化的算法，它用于比较前后两次状态的差异，以便于在重新渲染页面时只更新变化的部分，而不是整个页面都进行重新渲染。

Diff算法的核心思想是基于虚拟DOM（Virtual DOM）的比较和更新。在进行数据更新时，会先生成一个新的虚拟DOM树，然后将它与旧的虚拟DOM树进行比较，找出两棵树之间的差异，最后只更新变化的部分。

Diff算法主要分为三个步骤：

1. 对比同级节点

首先比较两个列表的第一个节点，如果相同，则继续比较下一个节点，如果不同，则向下比较，直到找到相同的节点或者到达列表的末尾。

1. 对比子节点

如果两个节点相同，则会递归地对它们的子节点进行比较，找到子节点之间的差异。

1. 更新差异

对于找到的差异，通过操作DOM来进行更新，从而完成页面的更新。

Diff算法在Vue和React等前端框架中得到了广泛应用，这些框架都是基于虚拟DOM和Diff算法来实现高效的数据更新和页面渲染的。

最长递增子序列算法是求解一个数列中最长递增子序列的长度的问题，也可以是求解最长递增子序列本身。该算法的核心思想是动态规划。

动态规划算法的基本思想是将一个大问题拆分为多个相似的子问题来解决，通过将子问题的解缓存下来，避免了大量的重复计算，提高了效率。对于最长递增子序列问题，可以采用以下的动态规划算法：

1. 创建一个长度为 n 的数组 dp，用于存储以 nums[i] 结尾的最长递增子序列的长度，初始化 dp[i] = 1，因为一个数本身就可以作为一个长度为 1 的递增子序列。
2. 对于每个 0 ≤ i < n，遍历 i 前面的每个元素 0 ≤ j < i，如果 nums[i] > nums[j]，则可以将 nums[i] 加入 nums[j] 的递增子序列中，形成一个新的递增子序列，此时 dp[i] 可以更新为 dp[j] + 1，表示以 nums[i] 结尾的最长递增子序列长度为以 nums[j] 结尾的最长递增子序列长度加上 1。
3. 最后，遍历 dp 数组，找到其中的最大值，即为原数列的最长递增子序列长度。

二分查找是一种查找算法，它通过将查找的值与已排序数组的中间值进行比较，从而将待查找区间缩小一半，直到找到该值或者确定该值不存在为止。二分查找的时间复杂度为 O(log n)，比线性查找更快。在最长递增子序列算法中，可以采用二分查找优化子序列的查找效率。

贪心算法是一种选择当前状态下最优解的算法，通过每次选择当前最优解来达到全局最优解。贪心算法的实现需要满足贪心选择性质和最优子结构性质。在最长递增子序列算法中，可以采用贪心算法来优化动态规划算法，即将 dp 数组中的值存储为递增子序列中每个长度的最小末尾值，这样可以保证递增子序列的长度不变，但子序列的可能末尾值更小，从而有助于后续元素的加入。

## 响应式原理 追问 为什么使用位运算

在 Vue.js 中，响应式原理是通过使用 JavaScript 的 `Object.defineProperty()` 方法实现的，该方法可以劫持对象的属性访问，从而实现对数据变化的监听。在 Vue.js 2.x 中，每个组件实例都有一个对应的 `Watcher` 对象，用来订阅数据变化并更新视图，每个 `Watcher` 对象内部维护了一个依赖列表，记录了当前组件渲染所依赖的所有数据项。

当数据发生变化时，Vue.js 会触发一个“依赖通知”的过程，通知所有依赖该数据的 `Watcher` 对象重新计算，进而更新视图。这个过程中，Vue.js 会使用 `nextTick()` 方法将多个视图更新操作合并成一个异步任务，以提高性能。

在实现过程中，Vue.js 使用了一个名为“位运算”的技巧，将数据的订阅和取消订阅的操作通过二进制位运算来实现，从而减少了内存的占用，提高了性能。这个技巧是因为 JavaScript 中的对象属性名只能是字符串，为了区分不同的数据依赖，Vue.js 将每个数据的依赖 ID 存储在一个叫做“订阅者 ID”（subscribing ID）的变量中，而这个变量是一个二进制数，通过位运算可以快速地进行添加和删除操作。

最长递增子序列（LIS）算法是一种经典的动态规划算法，用于查找一个序列中的最长递增子序列。该算法的核心思想是通过构建一个辅助数组来记录每个位置上的最长递增子序列长度，并不断更新这个数组，最终得到整个序列的最长递增子序列长度。

二分查找是一种常用的查找算法，适用于在有序数组中查找某个元素。该算法的核心思想是不断将查找范围缩小一半，直到找到目标元素或者查找范围为空。

贪心算法是一种常用的优化算法，用于在满足一定约束条件的情况下，寻找问题的最优解。该算法的核心思想是每次选择当前看起来最优的方案，并希望这种局部的最优解最终能够达到全局的最优解。与动态规划算法不同，贪心算法不需要穷举所有可能的解，因此具有更高的效率和更好的可扩展性。

## Vue源码调度机制 以及nextTick执行机制

Vue源码中的调度机制主要基于异步队列和事件循环实现。当响应式数据发生变化时，会触发异步队列更新操作，然后在下一个事件循环周期执行队列中的更新任务。在执行更新任务的过程中，会对组件进行合并和去重，以避免重复更新和提高效率。

而nextTick的执行机制，则是基于微任务实现。在Vue中，当数据发生变化后，需要立即获取更新后的DOM节点尺寸等信息，然后才能进行下一步的操作，这就需要在DOM更新后立即执行一些任务。而使用Promise.then的回调函数会在当前事件循环周期结束后立即执行，但这还不够快。因此Vue使用了微任务，即在当前任务执行完成后立即执行的任务，来实现nextTick的执行。在浏览器环境下，Vue使用的是MutationObserver API来监听DOM变化，然后在回调函数中执行nextTick任务。而在Node.js环境下，则使用了process.nextTick函数来实现nextTick的执行。

总的来说，Vue的调度机制和nextTick执行机制都是为了提高组件更新的效率和性能，并且兼顾了浏览器和Node.js环境的差异。

## Vue3 新增2个内置组件 介绍

在 Vue 3 中，新增了两个内置组件，分别是 `<Teleport>` 和 `<Suspense>`。

`<Teleport>` 组件可以让你在组件内部进行跨 DOM 移动，即可以将组件的 DOM 结构插入到组件树之外的其他位置，它可以接受一个 `to` 属性，将组件插入到指定的 DOM 元素中。

`<Suspense>` 组件可以帮助你处理异步组件的状态，在异步组件加载过程中，可以显示一个自定义的等待组件，当异步组件加载完成后，再进行渲染，同时可以处理异步组件加载失败的情况。

这两个组件的引入，让 Vue 3 在开发体验和功能方面都有了更加丰富的提升，可以让开发者更加便捷地处理一些常见的组件开发场景。

## Vue3 keep-alive LRU 算法以及原理介绍

Vue3 中的 `keep-alive` 组件可以将动态组件缓存起来，避免多次创建和销毁带来的性能消耗，从而提升应用的性能表现。其中，`keep-alive` 组件使用了 LRU 缓存淘汰策略来管理缓存组件，即最近最少使用原则。当缓存队列已满且需要新增缓存组件时，`keep-alive` 会将队列最末尾的缓存组件移除，然后将新的组件加入队头。

LRU 缓存淘汰策略的实现主要基于一个双向链表和一个哈希表。哈希表用于快速定位缓存组件，双向链表则用于管理缓存组件的使用顺序。当缓存组件被访问时，会将其移动到链表头部；当需要移除缓存组件时，则将链表尾部的缓存组件移除。这样，经过多次访问后，链表头部的缓存组件即为最近使用的缓存组件，而链表尾部的缓存组件则为最近最少使用的缓存组件。

在 Vue3 中，`keep-alive` 组件还新增了一个 `include` 和 `exclude` 属性，用于指定需要缓存或排除的组件。例如，我们可以使用以下代码指定只有名称为 `MyComponent` 的组件才会被缓存：

```javascript
<template>
  <keep-alive :include="['MyComponent']">
    <router-view />
  </keep-alive>
</template>
```

总之，`keep-alive` 组件和 LRU 缓存淘汰策略的应用，为 Vue3 应用的性能优化提供了一定的帮助。

## Vue-router 原理 hash 和 history 以及 对应微前端 以及monorepo 架构

Vue-router 是 Vue.js 官方的路由管理器，是用来实现单页面应用 (SPA) 的核心库之一。

Vue-router 支持两种模式：hash 模式和 history 模式。

- hash 模式：使用 URL 的 hash 来模拟一个完整的 URL，因此不会向服务器发送请求，也不需要后端的支持。例如：http://localhost:8080/#/home。
- history 模式：使用 HTML5 的 history API 来实现路由的变化，因此需要后端的支持来配置路由，以防止路由变化时出现 404 错误。例如：http://localhost:8080/home。

在微前端和 monorepo 架构中，Vue-router 可以和其他应用共同使用同一个路由管理器，以实现统一的路由控制。

LRU 算法（Least Recently Used，最近最少使用算法）是一种常见的缓存淘汰算法，用于在缓存空间满时，选择最近最少使用的缓存数据进行清除，以便腾出空间缓存新的数据。在 Vue3 中，keep-alive 组件使用了 LRU 算法来管理缓存的组件实例，以实现高效的组件缓存和复用。

## Pinia vuex 设计模式 以及实现原理 为什么刷新数据丢失 以及解决方案

Pinia 和 Vuex 都是 Vue.js 的状态管理库，可以用于在组件之间共享数据。它们都基于 Flux 设计模式，但在具体实现上略有不同。

在 Vuex 中，存在一个全局的 Store，用于管理应用的所有状态，包括响应式地更新视图。这个 Store 包含多个 Module，每个 Module 可以包含多个状态、getter、mutation 和 action。Vuex 通过提交 mutation 和分发 action 来修改状态，并且提供了丰富的插件和调试工具。

Pinia 采用类似 Vuex 的思想，但是 Pinia 更加轻量和可扩展。Pinia 中的 Store 是基于 Vue 3 的响应式系统实现的，使用了新的 Composition API 来定义 Store，Module，State，Getter，Mutation 和 Action。和 Vuex 不同的是，Pinia 只提供了基础功能，例如响应式数据，Devtools 集成等。同时也提供了插件机制，方便用户扩展。

关于刷新数据丢失的问题，这是因为 Vuex 和 Pinia 的状态都是存在内存中的，当浏览器刷新时，所有内存中的状态都会丢失。解决这个问题有两种方法：

1. 使用浏览器的持久化存储（如 LocalStorage）将状态保存在本地，每次页面加载时读取本地存储的状态并恢复。
2. 在服务端使用 SSR（服务器端渲染）技术，将状态嵌入到 HTML 中，在客户端渲染时读取状态并恢复。

这两种方法都需要对状态进行序列化和反序列化，以便在本地存储或传输过程中进行处理。可以使用 JSON 序列化来实现这个过程。

## AOT 和 JIT 的区别

AOT和JIT是两种编译器模式，用于将高级语言编写的程序转换成计算机可执行的代码。它们的主要区别在于编译的时间点和方式。

AOT（Ahead-of-Time）编译器是在程序运行之前将源代码编译成机器代码。这样，在运行时，计算机只需要加载已编译的代码，并直接执行它，这样可以提高程序的启动速度和运行速度。AOT编译器通常用于静态语言和编译型语言，例如C++和Java。

JIT（Just-in-Time）编译器是在程序运行时将源代码编译成机器代码。它通过分析程序运行时的行为和上下文信息，动态生成并优化代码，以提高程序的性能。JIT编译器通常用于解释型语言，例如JavaScript和Python。

在前端开发中，AOT和JIT主要应用于编译Vue和Angular等框架。Vue使用的是编译时（AOT）模式，即在构建时将Vue模板编译成渲染函数，从而提高Vue应用程序的性能。而Angular支持AOT和JIT两种编译模式，可以根据需要进行选择。

总的来说，AOT编译器在程序运行前编译源代码，可以提高程序的启动速度和运行速度，但编译时间较长；JIT编译器在程序运行时编译源代码，可以根据运行时信息优化代码，提高程序的性能，但对启动时间和编译时间有一定影响。

## 扩容 动态缩容怎么做

在计算机中，扩容和动态缩容通常与数据结构和算法有关。具体实现可能因使用的数据结构和算法而异。以下是一些常见的实现方法：

1. **扩容：**当需要添加新元素到数据结构时，如果已有的空间不足，则需要扩容。扩容通常需要重新分配一块更大的内存空间，并将原有的元素复制到新的内存空间中。扩容的大小通常为原有空间的一倍或某个固定的增量值。
2. **动态缩容：**动态缩容是指在删除元素后，如果剩余的元素所占用的内存空间远远小于数据结构的总空间，则可以将数据结构的空间缩小。与扩容相反，动态缩容需要重新分配一块更小的内存空间，并将原有的元素复制到新的内存空间中。动态缩容的大小通常为当前已使用空间的一半或某个固定的减量值。

对于动态扩容和缩容的具体实现，常见的数据结构和算法有很多不同的方法。例如，在动态数组中，可以使用“按需分配”的方式，只有在需要添加新元素时才分配内存空间。在哈希表中，可以使用“加载因子”控制扩容和缩容的时机。在红黑树等平衡树中，可以使用“重构”操作来保持平衡并控制树高。

需要注意的是，动态扩容和缩容可能会导致频繁的内存分配和数据复制，对性能和资源消耗有一定的影响。因此，在实现时需要根据具体情况综合考虑空间利用率和性能的平衡。

## nginx 四层LB负载均衡 nginx七层LSB 负载均衡怎么做 nginx多机房异地容灾怎么做

Nginx是一款高性能、开源的Web服务器，也是一个反向代理服务器，它具有负载均衡、HTTP缓存、安全防护、动静分离等特性。

针对你的问题，Nginx的负载均衡有四层和七层两种：

1. **四层负载均衡（TCP/UDP负载均衡）**：Nginx通过四层负载均衡实现对TCP和UDP流量的负载均衡，它能够将客户端请求分配到不同的后端服务器上进行处理，从而提高系统的性能和可用性。常见的四层负载均衡算法有轮询（Round Robin）、最少连接（Least Connections）、IP Hash等。
2. **七层负载均衡（HTTP负载均衡）**：Nginx通过七层负载均衡实现对HTTP和HTTPS流量的负载均衡，它能够根据请求的URL、HTTP头等信息进行智能分发，从而更好地满足不同的业务需求。常见的七层负载均衡算法有轮询（Round Robin）、最少连接（Least Connections）、IP Hash、URL Hash、Header Hash等。

**针对多机房异地容灾，可以通过Nginx实现高可用性和容灾性：**

1. **双活/双向同步**：在两个机房中分别搭建一套相同的服务集群，将两个服务集群进行双向同步，可以保证在一个机房宕机时，另一个机房可以顶上来继续提供服务。
2. **内网负载均衡**：在两个机房中分别搭建一套服务集群，然后在两个机房之间搭建一个内网负载均衡器，将请求分配到对应的服务集群上，可以实现多机房负载均衡和容灾。
3. **DNS负载均衡**：在两个机房中分别搭建一套服务集群，然后通过DNS负载均衡实现将请求分配到对应的机房上，可以实现多机房负载均衡和容灾。

需要注意的是，在多机房异地容灾场景下，需要考虑数据同步和一致性等问题，这需要根据具体的业务需求进行设计和实现。

## 网关怎么做 网关熔断怎么做 网关分流怎么做 网关加密怎么做

网关是一种中间件，用于连接不同的微服务并提供统一的入口点。常见的网关包括API网关、网关服务器等。下面分别介绍网关的不同功能和实现方法。

**网关怎么做：**

网关通常作为微服务架构中的一部分来实现，它充当了整个微服务架构中的入口点。网关可以通过HTTP API，Websocket等与前端应用程序和移动客户端交互，并通过RPC、JMS等协议与后端微服务交互。

网关的实现方式通常有两种：自己编写和使用现成的网关框架。自己编写的网关通常需要考虑高可用性、可伸缩性、安全性等问题，需要投入大量的人力和物力资源。使用现成的网关框架可以大大缩短开发周期和降低开发成本，常见的网关框架包括Spring Cloud Gateway、Kong等。

**网关熔断怎么做：**

当微服务出现故障或异常时，网关可以使用熔断器来避免雪崩效应，保证整个系统的可用性。熔断器通常会监控微服务的调用状况，当微服务的错误率达到一定的阈值时，熔断器会自动断开与该微服务的连接，并返回一个预设的错误信息，避免对系统造成更大的影响。

常见的熔断器有Hystrix、Sentinel等。

**网关分流怎么做：**

网关可以根据请求的路由信息、请求头、查询参数等信息将请求分发到不同的微服务实例中。通常，网关会使用负载均衡算法来选择目标微服务，以实现高可用性和负载均衡。

常见的负载均衡算法有轮询、随机、加权轮询、加权随机、哈希等。

**网关加密怎么做：**

网关可以使用SSL/TLS来加密通信。SSL/TLS协议是一种安全传输协议，它通过在客户端和服务器之间建立安全通道来保证通信的机密性、完整性和可信度。SSL/TLS协议通常使用数字证书来认证服务器和客户端的身份，防止中间人攻击。

常见的SSL/TLS实现有OpenSSL、GnuTLS、mbed TLS等。网关通常需要配置SSL证书和私钥，以实现加密通信。

## FPS 帧率 requestIdleCallback performance

FPS（Frames Per Second）是指每秒钟能够重新渲染多少次屏幕，是衡量动画流畅度的重要指标。一般来说，60 FPS 是比较流畅的标准，而低于 30 FPS 则可能会感觉到卡顿。

requestIdleCallback 是一个浏览器 API，可以在浏览器空闲时执行一些任务，避免占用主线程，从而提高页面的响应速度和性能。它会在浏览器空闲时被调用，但不能保证在某个特定时间内一定会被调用，因此它不适合对时间要求严格的任务。

performance 是浏览器提供的一个 API，可以用来测量页面的性能，包括页面加载时间、资源加载时间、JS 执行时间等。performance API 可以帮助开发者找到页面性能瓶颈，并进行性能优化。

在实现动画时，我们可以使用 requestAnimationFrame API，它会在浏览器下一次重新渲染时执行回调函数，确保动画的流畅性。同时，我们也可以通过监控 FPS 来判断动画的流畅性是否达到要求，如果 FPS 过低，则可以考虑优化动画代码或者减少动画数量等措施。